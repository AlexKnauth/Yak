<!doctype html>
<meta charset=utf-8>
<title>Yak</title>
<link rel=stylesheet href=style.css>
<div class=header-fill></div>
<header>
    <div class=container>
        <h1>Yak</h1>
        <p>The first language of the funject paradigm.</p>
        <section class=interpreter>
<div class=prompt><div class=measure></div><textarea>factorial = {
    [0]: 1
    [@n]: @n * (factorial[@n - 1])
}
factorial[5]</textarea></div>
<div class=help>Use Shift+Enter to add a line</div>
        </section>
        <nav>
            <button class=try-yak>Try Yak</button>
            <a href=#>Welcome</a><a href=#install>Install</a><a href=#learn>Learn</a><a href=#docs>Docs</a>
        </nav>
    </div>
</header>
<div class=container><article>

<h1>Welcome</h1>
<p>Yak is a remarkably powerful scripting language that leverages the new concept of a funjectâ€”a programmatic construct with properties of both functions and objects. Funjects allow you to say anything you could with a function or object, but they also allow you to express things you couldn't before. Read more about the mythical founding of funjects.</p>

<p>Yak comes in three flavors: an Racket-based executable, an npm package, and an HTML include that interprets yak inline or included in the HTML. The executable supports parallelization and pretty much anything you'd find in Racket. The npm package gives you access to node.js through require statements and allows you to write entire servers. The third interpreter, once included on your webpage, interprets all script tags with the attribute type='text/yak'.</p>

<h1>Install</h1>
<div class=bookmark id="install"></div>
<p>The simplist way to get Yak is to include the following line in your HTML:</p>

<pre><code>&lt;script type=text/javascript src=//yak-lang.org/ys.js&gt;&lt;/script&gt;</code></pre>

<p>This will interpret all <code>&lt;script&gt;</code> tags written after it that contain the attribute <code>type=text/yak</code>. Any libraries you include (such as jQuery) you can access from Yak using our simple <a href='doc/js-bridge'>bridging pattern</a>.</p>

<p>You can download the Racket-based interpreter for <a href='download/Mac'>Mac OS X</a>, <a href='download/Windows'>Windows</a>, or <a href='download/Ubuntu'>Ubuntu</a>.</p>

<p>To use Yak with node, first download node, then run:</p>

<pre><code>npm install yak-lang</code></pre>

<p>You can then run yak files with the <code>yak</code> command and <code>require</code> node's <code>http</code> or <code>fs</code>.</p>

<h1>Learn</h1>
<div class=bookmark id="learn"></div>
<p>Yak is the first language ever of the funject paradigm. This means that rather than using traditional objects, or functions, Yak combines both concepts into a brand new thing called a funject. funjects are in essence the best parts of objects, the best parts of functions put together with some cool new ideas to make them mesh nicely with eachother. For those reading this who are already comfortable with programming, or who are very familiar with another dynamic language, you may wish to skim the first few sections, until you reach the secion on funjects, which is where we begin to explain all the new conecpts that make Yak different from other languages.</p>

<h2>Math</h2>
<p>Yak is a dynamic language, and like many other existing dynamic languages (Python, Ruby, Javascript, Lua, Smalltalk, etc.) you can perform basic mathematical calculations by simply writing the expression out. Here are some examples:</p>

<pre><code>>> # Before we show you the match examples, this is a quick example of a comment!
>> # We're showing you this now because they'll be used a lot in code blocks for explaining things.
>> # Anything that comes after a pound sign is a comment. Commends are pieces of code that are completely
>> # ignored when the code is run. Yak just skips over them. Comments are used to explain
>> # or document pieces of code.

>> 10 # Entering anything withuout any operands simply evaluates to itself so 10 evaluates to 10! Simple enough, right?
10
>> # Notice how after doing anything (excepting comments), what it evaluates to is printed on the next line.
>> #If it doesnt evaluate to anything, "nil" will be printed on the next line.
>> 3 + 2 # Now, for addition
5
>> 2 + 3 # You can switch the operands like in normal addition
5
>> 10 - 3
7
>> 3 - 10
-7
>> 5 * 4
20
>> 6 / 3
2
>> 3 / 6 # The result of the operation can be a decimal
0.5
>> 2 + 2.5 # Decimal numbers can be used as operands
4.25
>> 10 % 2 # There's even modulo!
0
>> # Another note before we move on...
>> #|
.. Block comments look like this!
.. A block comment is a comment that spans multiple lines!
.. This is useful for writing long comments without having to add a new comment character ('#')
.. at the beginning of every line.
.. |#</code></pre>

<p>Variables are things that can store values, variables can store just about any value, but for now, we'll use the for numbers. To "assign" a value to a variable, use the <code>=</code> operator. <code>=</code> takes the value on its left, and assigns it to the value on the right.</p>

<pre><code>>> hours = 3
3
>> hours # Like with numbers, Entering a variable without operands evaluates to its value
3
>> hours + 4 # You can treat a variable as if it was its value. That means we can add things to the hours variable.
7
>> seconds = 3 * 10 # You can assign variables to the result of another expression
30
>> minutes = hours * 60 # Those expressions can contain other variables
180
>> minutes = minutes + 5 # They can even be self referential!
185</code></pre>

<p>Multiple variables can be defined at once by "chaining" the expression together like so:</p>

<pre><code>>> a = b = c = d = e = f = 5
5
>> a
5
>> b
5
>> c
5
>> d
5
>> e
5
>> f
5</code></pre>

<p>Note that if you try and use a variable that hasn't already been defined (set to something using the <code>=</code> operator), an error will occur.</p>

<pre><code>>> speed + 10
Undefined variable speed
at input:1:1</code></pre>

<h2>Strings</h2>
<p>Strings are the next data type available in funject. Strings represent text. String values can be created by enclosing text in either single or double quotes.</p>

<pre><code>>> 'This is a string value!'
'This is a string value'
>> "This is also a string value"
'This is also a string value'
>> "This is not a string!' # You can't mix single and double quotes, if you start a string with one type, you have to end it with that type.
Unterminated string at input:4:1
>> 'You can use "double quotes" inside single quoted strings'
'You can use "double quote" inside single quoted strings'
>> "And you can use 'single quotes' inside double quoted strings"
'And you can use \'single quotes\' inside double quoted strings'</code></pre>

<p>The <code>print</code> funject is used to print values to the console. We haven't learned about funject calls yet, but bear with us, and trust that we will explain in full detail what's going on later, for now, all you need to know is this: The <code>print</code> funject prints a value. When you call the print funject, it will write the string you give it to the console. Here's an example of how to use the print funject:</p>

<pre><code>>> print['This string will be printed to the console!']
This string will be printed to the console!
nil
>> print['This string is cooler though...']
This string is cooler though...
nil</code></pre>

<p>Keep in mind that the <code>nil</code> printed after your string is there because as mentioned earlier, when something doesn't evaluate to anything, it instead writes <code>nil</code> as what it evaluated to. If you're running a yak file rather than using the REPL (Read Evaluate Print Loop, a.k.a. the console version of yak), <code>nil</code> will not show up, as the results of expressions are only printed in the REPL. Note that <code>print</code> can be used for any data type! But for now, we'll just worry about strings. Now we've seen how to make strings and print them, so let's say you want to combine two strings into one string. You would do this using concatenation. You can concatenate strings like this:</p>

<pre><code>>> print['This string ' + 'will be attached to this string']
This string will be attached to this string
nil
>> # You can also concatenate multiple strings at once like this
>> print['This string ' + 'will be attached to this one, AND ' + 'this one!']
This string will be attached to this one, AND this one!
nil
>> # You can even do this:
>> fruitSalad = 'apples' + 'and ' + 'oranges ' + 'and ' + 'grapes ' + 'and ' + 'bananas'
'apples and oranges and grapes and bananas'
>> print[fruitSalad + ' are ' + 'yummy, yummy!']
apples and oranges and grapes and bananas are yummy, yummy!
nil</code></pre>

<p>There are also some characters that can't be written in strings. If you want to use them in a string, you instead input the character <code>\</code> followed by the code for the character you want to replace. Heres a list of commonly used escapes:</p>
<ul>
    <li><code>\n</code> is a newline character</li>
    <li><code>\r</code> is a carriage return character. These are used in windows line endings, but dont worry about them too much, just use <code>\n</code></li>
    <li><code>\t</code> is a horizontal tab character</li>
    <li><code>\'</code> escapes a single quote (for use in a single quote encapsulated string)</li>
    <li><code>\"</code> escapes a double quote (for use in a double quote encapsulated string)</li>
    <li><code>\\</code> escapes the escape character, so it represents a backslash</li>
</ul>
<p>Here's an example for the use of each escape character</p>

<pre><code>>> print['This makes\na new line']
This makes
a new line
nil
>> print['\t Makes a tab character']
Makes a tab character
nil
>> print['With escapes, you can use a \'single quote\' inside of a single quoted string']
With escapes, you can use a a 'single quote' inside of a double quoted string
nil
>> print["or \"double quotes\" within a double quoted string"]
or "double quotes" within a double quoted string
nil
>> print['And last but not least, you can use the \\ character by escaping it with itself!']
And last but not least, you can use the \ character by escaping it with itself!
nil</code></pre>

<p>Behind the scenes, strings are actually just a bunch of characters strung together. (hence why they're called "strings"). This means that if you want to, you can get an individual character from a string like this:</p>

<pre><code>>> lyric = 'bananas'
'bananas'
>> print['This **** is ' + lyric]
This **** is bananas
nil
>> print[lyric[0]]
b
nil
>> print[lyric[1]]
a
nil
>> print[lyric[2]]
n
nil
>> print[lyric[3]]
a
nil
>> print[lyric[4]]
n
nil
>> print[lyric[5]]
a
nil
>> print[lyric[6]]
s
nil</code></pre>

<p>If you try and get the character at a negative index, it gives you the character at that index if you were counting from the end! <code>-0</code> is the same as 0, so the last character is indexed at <code>-1</code>.</p>

<pre><code>>> word = 'hello!'
'hello!'
>> reversed = word[-1] + word[-2] + word[-3] + word[-4] + word[-5]
'!olleh'</code></pre>

<p>One nice feature of strings is the ability to get their length. This is done using the <code><var>somelist</var>.length</code> property. This is particularly useful, as it allows you to easily determine the index of the last element in the string.</p>

<pre><code>>> animals = ['cow', 'chicken', 'horse', 'dog', 'cat', 'mouse', 'owl']
['cow', 'chicken', 'horse', 'dog', 'cat', 'mouse', 'owl']
>> animals.length
7
>> animals[animals.length - 1]
'owl'</code></pre>

<p>Finally, because strings are so good at displaying information, you can get the string representation of anything by using <code>.to-string</code>. <code>.to-string</code> can be used like this:</p>

<pre><code>>> 10.to-string # For example, numbers
'10'
>> (20 + 30).to-string
'50'
>> (3 / 2).to-string
'1.5'
>> 'You can even use to-string on strings! It doesn\'t do much though...'.to-string
'You can even use to-string on strings! It doesn\'t do much though...'
>> # nil is the special funject that is returned whenever an operation doesn't evalate to anything, and you can even use to-string on it!
>> nil.to-string
'nil'</code></pre>

<h2>Lists</h2>
<p>Lists are essentially a single data type that can hold other data types. They're exactly like they sound, a way to <em>list</em> or group other values. Note that lists <em>can</em> contain multiple different types, but do not have to. Lists look like this:</p>

<pre><code>>> tenToPowersAndFruits = ['apples', 10, 'banana', 100, 'starfruit', 10000]
['apples', 10, 'banana', 100, 'starfruit', 1000]</code></pre>

<p>Unlike strings, lists are mutable. This means that you can change a single element of the list, without reassigning the entire list.</p>

<pre><code>>> colors = ['red', 'starfruit', 'blue']
['red', 'starfruit', 'blue']
>> # Oh no! starfruit isn't a color! Let's change it to green.
>> colors[1] = 'green'
['red', 'green', 'blue']
>> # Now, when we check the value of colors, we can see that it has changed!
>> colors
['red', 'green', 'blue']</code></pre>

<p>Many of the concepts you learned about strings earlier can also be applied to lists, because strings can be thought of as lists of single characters. (The main difference is that strings are immutable.) Here are some examples of concepts you learned with strings being applied to lists.</p>

<pre><code># You can concatenate arrays, just like you can strings
>> snowsports = ['hockey', 'skiing']
['hockey', 'skiing']
>> watersports = ['surfing', 'swimming']
['surfing', 'swimming']
>> teamsports = ['football', 'baseball', 'basketball']
['football', 'baseball', 'baskeyball']
>> sports = snowsports + watersports + teamsports
['hockey', 'skiing', 'surfing', 'swimming', 'football', 'baseball', 'basketball']
# You can also make arrays into strings using the to-string funject, and get their length with the length funject
>> users = ['jake', 'lucy', 'katherine']
['jake', 'lucy', 'katherine']
>> print['You have ' + users.length.to-string + ' and their names are: ' + users.to-string]
You have 3 users and their names are: ['jake', 'lucy', 'katherine']</code></pre>

<p>Lists can contain any data type, and that includes lists! This means that you can nest lists within each other.</p>

<pre><code>>> # In this example, coordinates represents a list of lists of x and y coordinates.
>> coordinates = [[10, 30], [40, 10], [21, 26], [3, 22]]
[[10, 30], [40, 10], [21, 26], [3, 22]]
>> # Let's say we want to get the y value of the coordinate pair at the index 2, we would do it like this
>> coordinates[2][1]
26
>> # Here are some other values, simply for demonstration
>> coordinates[0][0]
10
>> coordinates[0][1]
30
>> coordinates[3, 0]
3</code></pre>

<h2>Funjects</h2>
<p>Now that we've gotten through the basic introduction to types, and programming in Yak, we can start to talk about funjects. Tutorials for many other languages would around this point being to explain how functions, and objects work, but Yak replaces both concept with the universal funject, so we have this section instead. Let's get to it!</p>

<p>The first thing to remember, is that <strong>everything</strong> in Yak is a funject. Because of this, funjects have a lot of cool properties. Let's start by creating an empty funject. funjects in yak are represented by an open curly brace (<code>{</code>), the body of the funject (we'll get to that later), followed a close curly brace (<code>}</code>) which signifies the end of the funject body. So let's start by simply declaring an empty funject.</p>

<pre><code>>> afunject = {}
#&lt;funject>
>> # Note that the REPL represents funjects as just #&lt;funject></code></pre>

<p>So far, nothing too interesting. We set afunject to an empty funject, and it evaluates to <code>{}</code>. Now, we can talk about what funjects interesting: pattern matching. Funjects, like functions, can be used to execute blocks of code with parameters, however the process they go through to do this is different. Consider the following code block. (explanation below)</p>

<pre><code>>> example = {
..     [0]: 1
..     [5]: 2
.. }
#&lt;funject>
>> example[0]
1
>> example[5]
2</code></pre>

<p>Here, we define <code>example</code>, a funject with two patterns in it. These two patterns match a list containing only the element 0, and a list containing only the element 5. Then further down, we invoke the funject example with a list containing one element 0, and again with 5. When Yak is given this code, here's what it's doing.</p>

<p>First, Yak creates a funject and assigns it to <code>example</code>. This funject has two patterns: one that matches <code>[0]</code>, and another that matches <code>[1]</code>. Then, it invokes eample with the argument <code>[0]</code>. When a funject is invoked, Yak goes through the funject and looks for any patterns that match the argument passed. When it finds a pattern that matches the argument, it then evaluates the expression after the colon and returns the result of that expression. In this case, it finds that the argument, <code>[0]</code>, matches the first pattern, evaluates the expression mapped to that, which comes out as 1, and returns that 1. Thus <code>example[0]</code> is 1. Later, Yak does the same thing for <code>example[5]</code>, which matches the pattern <code>[5]</code> and returns 2.</p>

<p>One thing to note is that you can format your code in two different ways when writing the expression for a pattern match. If you only need one line of code, you might do this:</p>

<pre><code>>> foo = {
..     ['a']: 3
.. }
&lt;funject>
>> foo['a']
3</code></pre>

<p>But if you wanted the pattern to map to multiple lines of code, you would write it like this:</p>

<pre><code>>> foo = {
..    ['a']:
..        number = 1 + 1
..        number * 3
.. }
>> foo['a']
6</code></pre>

<p>If you have a multiple line expression like this, and you don't indent consistently, the Yak interpreter will throw an error. This is because the end of the expression, is signified by unindenting, so proper identation is necessary. Note that with a multiple line expression, the result of the <em>last</em> expression is returned.</p>

<p>Let's say though we wanted to define a funject that could take a wide range of things as its argument. It would be horrible if you had to explicitly define an output for every single input. So for that, there are parameters. In a pattern, any time you use the <code>@</code> symbol followed by an alphanumeric string to accept anything as input. Consider this code: (also explained below)</p>

<pre><code>>> addOne = {
..     [@number]: @number + 1
.. }
&lt;funject>
>> addOne[4]
5
>> addOne[-2]
-1
>> addOne[9]
10</code></pre>

<p>Here, <code>addOne</code> contains a pattern that matches the parameter @number. When a pattern contains a parameter it allows anything to be in the place of that parameter. It also <strong>binds</strong> the value to that parameter. When a parameter has been bound to a value, the parameter acts like a variable whos value is set to what it was bound to. That's why in the <code>addOne</code> example, the expression <code>@number + 1</code> evaluates to whatever you passed as an argument plus one.</p>

<p>For those of you new to programming, the idea of recursion might seem foreign to you. Recursion, is invoking one funject from within itself. This is usefull for all sorts of things, and is used a lot in math funjects. In this example, we'll show you how to use recursion, and pattern matching, to make the famous recursive factorial function in Yak.</p>

<p>Recursive factorial works by first using something called a <strong>base case</strong>, which checks if the input is a certain value, and if it is, returns a fixed value. For factorial the base case is 0, which should always return 1. Because of pattern matching, we can easily make the base case without having to use any control flow as one might in another language. Then, if the argument is anything other than the base case, factorial returns the argument times factorial invoked with the argument being the original argument minus one. The implementation of the funject would look like this.</p>

<pre><code>>> factorial = {
..     [0]: 1 # Base case, if the argument is zero, factorial will always return one
..     [@number]: @number * factorial(@number - 1)
.. }
&lt;funject>
>> factorial[5]
120</code></pre>

<p>To better understand why this works, here's a list of what the code would do when you call <code>factorial[5]</code>. If you already have a understanding of recursion, you can skip over this.</p>

<ol>
    <li>Invokes factorial with the argument <code>[5]</code></li>
    <li>Takes 5, and multiplies it by <code>factorial[5 - 1]</code> (overall expression: <code>5 * factorial[4]</code>)</li>
    <li>Takes 4, and multiplies it by <code>factorial[4 - 1]</code> (overall expression: <code>5 * 4 * factorial[3]</code>)</li>
    <li>Takes 3, and multiplies it by <code>factorial[3 - 1]</code> (overall expression: <code>5 * 4 * 3 * factorial[2]</code>)</li>
    <li>Takes 2, and multiplies it by <code>factorial[2 - 1]</code> (overall expression: <code>5 * 4 * 3 * 2 * factorial[1]</code>)</li>
    <li>Takes 1, and multiplies it by <code>factorial[1 - 1]</code> (overall expression: <code>5 * 4 * 3 * 2 * 1 * factorial[0]</code>)</li>
    <li>Finds that <code>[0]</code> matches the base case, so it evaluates to one</li>
    <li>This leaves the final expression as <code>5 * 4 * 3 * 2 * 1 * 1</code>, which is exactly what 5! (factorial) does in mathematics!</li>
</ol>

<h1>Docs</h1>
<div class=bookmark id="docs"></div>

</article></div>
<script src=yak.js></script>
