// Generated by CoffeeScript 1.6.3
(function() {
  var BaseFunject, BooleanFunject, ClassFunject, Funject, IDENTIFIER_CHARS, Interpreter, InterpreterError, ListFunject, MAX_ITERATIONS, MatchError, MutationObserver, NO_MATCH, NumberFunject, RuntimeError, SPECIAL_FORM, Scope, StringFunject, SymbolFunject, UserError, arg, argc, e, environment, equal, evaluate, evaluateSynchronous, expression, expressionNumber, expressions, extend, fs, globalScope, i, integerIdentityInverse, interactive, interpret, interpreted, itself, k, lang, last, logical, onInserted, operator, p, parse, parseError, parseForRacket, parser, path, printTokens, printTree, proxy, racket, repl, stringify, tokenizer, tokens, v, variable, verbose, yakBoolean, yakClass, yakFunction, yakObject, yakSymbol, _exports, _i, _j, _len, _len1, _ref, _ref1, _ref2,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  IDENTIFIER_CHARS = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-+*/%^_$<>=?!';

  parseError = function(token, message) {
    throw new SyntaxError("" + message + " at " + token.file + ":" + token.line + ":" + token.character);
  };

  last = function(thing) {
    return thing[thing.length - 1];
  };

  tokenizer = (function() {
    var isDigit, isIdentifier, isSpace, symbol;
    symbol = {
      '(': 'group start',
      ')': 'group end',
      '{': 'funject start',
      '}': 'funject end',
      '[': 'list start',
      ',': 'list delimiter',
      ']': 'list end',
      ':': 'pattern match',
      '=': 'strict assignment',
      ':=': 'lazy assignment',
      '|=': 'reset strict assignment',
      '|:=': 'reset lazy assignment',
      '<-': 'inverse assignment',
      '<<': 'inheritance assignment',
      '::': 'prototypal application'
    };
    isSpace = function(c) {
      return c === ' ' || c === '\t';
    };
    isDigit = function(c) {
      return -1 !== '0123456789'.indexOf(c);
    };
    isIdentifier = function(c) {
      return -1 !== IDENTIFIER_CHARS.indexOf(c);
    };
    return function(raw, file, startLine) {
      var a, advance, b, c, character, here, i, indent, j, lastNewline, length, line, next, pairs, prev, s, start, syntaxError, token, tokens;
      if (file == null) {
        file = '<anonymous>';
      }
      if (startLine == null) {
        startLine = 1;
      }
      token = function(type, value) {
        if (value == null) {
          value = '';
        }
        return {
          type: type,
          value: value,
          line: line,
          file: file,
          character: character
        };
      };
      syntaxError = function(message) {
        throw new SyntaxError("" + message + " at " + file + ":" + line + ":" + character);
      };
      s = '';
      i = 0;
      while (true) {
        j = raw.indexOf('#', i);
        if (j === -1) {
          break;
        }
        s += raw.substring(i, j);
        i = j + 1;
        c = raw[i];
        if (c === '|') {
          ++i;
          start = i;
          pairs = 1;
          while (pairs) {
            a = raw.indexOf('#|', i);
            b = raw.indexOf('|#', i);
            if (a === -1 && b === -1) {
              throw new SyntaxError("Unmatched multiline comment");
            }
            if (a !== -1 && (a < b || b === -1)) {
              ++pairs;
              i = a + 2;
            }
            if (b !== -1 && (b < a || a === -1)) {
              --pairs;
              i = b + 2;
            }
          }
          s += Array(raw.substring(start, i).split('\n').length).join('\n');
        } else {
          j = raw.indexOf('\n', i);
          if (j === -1) {
            break;
          }
          i = j;
        }
      }
      s += raw.substring(i);
      i = 0;
      character = 0;
      lastNewline = 0;
      line = startLine;
      length = s.length;
      indent = [''];
      tokens = [];
      advance = function() {
        var delimiter, digit, l, now, prev, q, space, type, value;
        if (tokens.length) {
          return tokens.shift();
        }
        c = s[i];
        while (isSpace(c)) {
          ++i;
          c = s[i];
        }
        character = 1 + i - lastNewline;
        if (i >= length) {
          if (indent.length > 1) {
            indent.pop();
            return token('outdent');
          }
          return token('end');
        }
        if ((q = s.substr(i, 3)) === '|:=' || (q = s.substr(i, 2)) === ':=' || q === '|=' || q === '<-' || q === '<<' || q === '::') {
          i += q.length;
          return token(symbol[q], q);
        }
        switch (c) {
          case '\n':
          case '\r':
            while (true) {
              while (c === '\n' || c === '\r') {
                ++i;
                ++line;
                lastNewline = i;
                character = 1 + i - lastNewline;
                c = s[i];
              }
              space = '';
              while (true) {
                c = s[i];
                if (!isSpace(c)) {
                  break;
                }
                space += c;
                ++i;
              }
              if (!(c === '\n' || c === '\r')) {
                break;
              }
            }
            l = last(indent);
            now = space.length;
            prev = l.length;
            switch (false) {
              case now !== prev:
                if (space !== l) {
                  syntaxError('Inconsistent indentation');
                }
                return token('newline');
              case !(now < prev):
                while (now < prev) {
                  tokens.push(token('outdent'));
                  indent.pop();
                  l = last(indent);
                  prev = l.length;
                }
                if (c && space !== l) {
                  syntaxError('Inconsistent indentation');
                }
                return tokens.shift();
              case !(now > prev):
                if (l !== space.substr(0, prev)) {
                  syntaxError('Inconsistent indentation');
                }
                indent.push(space);
                return token('indent');
            }
            break;
          case '{':
          case '}':
          case '[':
          case ']':
          case ':':
          case '=':
          case ',':
          case '(':
          case ')':
            ++i;
            if (c === '=' && s[i] === '=') {
              --i;
            } else {
              return token(symbol[c], c);
            }
        }
        if (c === '-') {
          q = s[i + 1];
          if (q === '.' || isDigit(q)) {
            digit = true;
          }
        }
        if (digit || c === '.' || isDigit(c)) {
          value = '';
          start = i;
          if (c === '-') {
            value += c;
            ++i;
            c = s[i];
          }
          if (isDigit(c)) {
            while (true) {
              value += c;
              ++i;
              c = s[i];
              if (!isDigit(c)) {
                break;
              }
            }
          }
          b = false;
          if (c === '.') {
            value += c;
            ++i;
            c = s[i];
            if (!isDigit(c)) {
              --i;
              c = s[i];
              if (value !== '.') {
                return token('number', +value.substr(0, value.length - 1));
              }
              b = true;
            } else {
              while (true) {
                value += c;
                ++i;
                c = s[i];
                if (!isDigit(c)) {
                  break;
                }
              }
            }
          }
          if (!b) {
            if (c === 'e' || c === 'E') {
              value += c;
              ++i;
              c = s[i];
              if (c === '+' || c === '-') {
                value += c;
                ++i;
                c = s[i];
              }
              if (!isDigit(c)) {
                character = 1 + i - lastNewline;
                syntaxError('Expected digit');
              }
              while (true) {
                value += c;
                ++i;
                c = s[i];
                if (!isDigit(c)) {
                  break;
                }
              }
            }
            if (isIdentifier(c)) {
              i = start;
              c = s[i];
            } else {
              return token('number', +value);
            }
          }
        }
        if (c === '@' || c === '.' || isIdentifier(c)) {
          type = c === '@' ? 'formal parameter' : c === '.' ? 'symbol' : 'identifier';
          value = '';
          while (true) {
            value += c;
            ++i;
            c = s[i];
            if (!isIdentifier(c)) {
              break;
            }
          }
          if (value === 'true' || value === 'false') {
            return token('boolean', value === 'true');
          }
          if (-1 !== ['nil', 'unknown', 'class', 'module', 'try', 'catch', 'finally', 'if', 'then', 'else'].indexOf(value)) {
            return token(value, value);
          }
          if (type === 'symbol') {
            if (value.length === 1) {
              character = 1 + i - lastNewline;
              syntaxError('Expected identifier');
            }
            return token(type, value.substr(1));
          }
          return token(type, value);
        }
        if (c === '"' || c === "'") {
          delimiter = c;
          value = '';
          ++i;
          c = s[i];
          while (true) {
            if (c === delimiter) {
              break;
            }
            if (c === '\\') {
              ++i;
              switch (c = s[i]) {
                case '"':
                case "'":
                case '\\':
                  value += c;
                  break;
                case 'n':
                  value += '\n';
                  break;
                case 'r':
                  value += '\r';
                  break;
                case 't':
                  value += '\t';
                  break;
                default:
                  character = 1 + i - lastNewline;
                  syntaxError('Invalid escape sequence');
              }
              ++i;
              c = s[i];
              continue;
            }
            if (!c) {
              syntaxError('Unterminated string');
            }
            value += c;
            ++i;
            c = s[i];
          }
          ++i;
          return token('string', value);
        }
        return syntaxError("Unexpected " + c);
      };
      here = advance();
      next = advance();
      prev = null;
      return {
        here: function() {
          return here;
        },
        next: function() {
          return next;
        },
        advance: function() {
          prev = here;
          here = next;
          next = advance();
          return prev;
        },
        match: function() {
          var types;
          types = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          if (-1 !== types.indexOf(here.type)) {
            return this.advance();
          }
          if (prev && prev.type === 'outdent' && -1 !== types.indexOf('newline')) {
            return {
              type: 'newline',
              value: '',
              file: prev.file,
              line: prev.line,
              character: prev.character
            };
          }
          return null;
        },
        accept: function() {
          var values;
          values = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          if (-1 !== values.indexOf(here.value)) {
            return this.advance();
          }
          return null;
        },
        require: function() {
          var types;
          types = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return this.match.apply(this, types) || parseError(here, "Expected " + (types.join(" or ")));
        },
        requireValue: function() {
          var values;
          values = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return this.accept.apply(this, values) || parseError(here, "Expected '" + (values.join("', '")) + "'");
        }
      };
    };
  })();

  parse = (function() {
    var BINARY_OPERATORS, PREFIX_OPERATORS, Symbol, expression, pattern, sequence, symbols, value;
    symbols = {};
    BINARY_OPERATORS = {
      '^': -7,
      '*': 6,
      '/': 6,
      '%': 6,
      '+': 5,
      '-': 5,
      '>': 4,
      '<': 4,
      '>=': 4,
      '<=': 4,
      '==': 3,
      '!=': 3,
      'is': 3,
      'isnt': 3,
      'and': 2,
      'or': 2
    };
    PREFIX_OPERATORS = {
      'not': 2
    };
    Symbol = (function() {
      function Symbol() {}

      Symbol.prototype["null"] = function() {
        return parseError("Unexpected operator");
      };

      Symbol.prototype.left = function() {
        return parseError("Unexpected value");
      };

      return Symbol;

    })();
    parse = function(s, file, startLine) {
      var result, tokens;
      tokens = tokenizer(s, file, startLine);
      while (tokens.match('newline')) {}
      result = sequence(tokens);
      tokens.require('end');
      return result;
    };
    sequence = function(tokens) {
      var n, result, s;
      n = tokens.here();
      result = [];
      while (true) {
        s = expression(tokens, 0, true);
        if (!s) {
          break;
        }
        result.push(s);
        if (!tokens.match('newline')) {
          break;
        }
      }
      return {
        file: n.file,
        line: n.line,
        character: n.character,
        type: 'sequence',
        expressions: result
      };
    };
    expression = function(tokens, precedence, optional, noIndent) {
      var assignment, body, condition, cont, e, ep, falseBody, handler, name, op, operand, p, parent, result, start, symbol, t, trueBody, _class;
      if (precedence == null) {
        precedence = 0;
      }
      if (tokens.match('indent')) {
        result = sequence(tokens);
        tokens.require('outdent');
        return result;
      }
      if (start = tokens.match('class', 'module')) {
        if (name = tokens.match('identifier')) {
          while (true) {
            if (t = tokens.match('symbol')) {
              name = {
                type: 'application',
                file: t.file,
                line: t.line,
                character: t.character,
                funject: name,
                argument: t
              };
              continue;
            }
            break;
          }
        }
        if (tokens.accept('<')) {
          parent = expression(tokens, 0, false, true);
        }
        if (tokens.here().type !== 'indent') {
          parseError(tokens.here(), "Expected indent");
        }
        body = expression(tokens);
        result = {
          type: start.type,
          file: start.file,
          line: start.line,
          character: start.character,
          body: body,
          parent: parent
        };
        if (!name) {
          return result;
        }
        return {
          type: 'assignment',
          operator: 'strict assignment',
          file: start.file,
          line: start.line,
          character: start.character,
          left: name,
          right: result
        };
      }
      if (start = tokens.match('try')) {
        if (tokens.here().type !== 'indent') {
          parseError(tokens.here(), "Expected indent");
        }
        body = expression(tokens);
        tokens.require('catch');
        _class = tokens.require('identifier');
        name = tokens.match('identifier');
        if (tokens.here().type !== 'indent') {
          parseError(tokens.here(), "Expected indent");
        }
        handler = expression(tokens);
        result = {
          type: 'try',
          file: start.file,
          line: start.line,
          character: start.character,
          body: body,
          "class": _class,
          "catch": handler
        };
        if (name) {
          result.name = name;
        }
        if (tokens.match('finally')) {
          result["finally"] = expression(tokens);
        }
        return result;
      }
      if (start = tokens.match('if')) {
        condition = expression(tokens, 0, false, true);
        if (tokens.here().type !== 'indent') {
          tokens.require('then');
        }
        trueBody = expression(tokens);
        if (tokens.match('else')) {
          if (tokens.here().type !== 'indent' && !tokens.here().type === 'if') {
            parseError(tokens.here(), "Expected indent");
          }
          falseBody = expression(tokens);
        }
        return {
          type: 'if',
          file: start.file,
          line: start.line,
          character: start.character,
          condition: condition,
          trueBody: trueBody,
          falseBody: falseBody
        };
      }
      e = value(tokens);
      if (!e) {
        if (optional) {
          return null;
        } else {
          parseError(tokens.here(), "Expected expression");
        }
      }
      while (true) {
        if (t = tokens.match('symbol')) {
          e = {
            type: 'application',
            file: t.file,
            line: t.line,
            character: t.character,
            funject: e,
            argument: t
          };
          continue;
        }
        if (tokens.here().type === 'list start') {
          t = tokens.here();
          e = {
            type: 'application',
            file: t.file,
            line: t.line,
            character: t.character,
            funject: e,
            argument: value(tokens)
          };
          continue;
        }
        if (precedence < 7) {
          if (tokens.here().type === 'identifier') {
            cont = false;
            for (op in BINARY_OPERATORS) {
              p = BINARY_OPERATORS[op];
              if (precedence < Math.abs(p) && (t = tokens.accept(op))) {
                e = {
                  type: 'application',
                  file: t.file,
                  line: t.line,
                  character: t.character,
                  funject: e,
                  argument: t
                };
                ep = p < 0 ? -1 - p : p;
                if (operand = expression(tokens, ep, true, noIndent)) {
                  e = op === 'and' || op === 'or' ? {
                    type: op,
                    file: t.file,
                    line: t.line,
                    character: t.character,
                    left: e.funject,
                    right: operand
                  } : {
                    type: 'application',
                    file: t.file,
                    line: t.line,
                    character: t.character,
                    funject: e,
                    argument: operand
                  };
                }
                cont = true;
                break;
              }
            }
            if (cont) {
              continue;
            }
          }
          if ('identifier' === tokens.here().type && !BINARY_OPERATORS[tokens.here().value] || -1 !== ['formal parameter', 'string', 'number', 'boolean', 'nil', 'unknown', 'funject start', 'group start', 'list start'].indexOf(tokens.here().type)) {
            t = tokens.here();
            e = {
              type: 'application',
              file: t.file,
              line: t.line,
              character: t.character,
              funject: e,
              argument: expression(tokens, 7, false, noIndent)
            };
            continue;
          }
          if (t = tokens.match('prototypal application')) {
            symbol = tokens.require('identifier');
            symbol.type = 'symbol';
            e = {
              type: 'application',
              file: t.file,
              line: symbol.line,
              character: symbol.character,
              funject: {
                type: 'application',
                file: t.file,
                line: t.line,
                character: t.character,
                funject: e,
                argument: {
                  type: 'symbol',
                  file: t.file,
                  line: t.line,
                  character: t.character,
                  value: 'instance'
                }
              },
              argument: symbol
            };
            continue;
          }
          if (!noIndent && 'indent' === tokens.here().type) {
            t = tokens.here();
            e = {
              type: 'application',
              file: t.file,
              line: t.line,
              character: t.character,
              funject: e,
              argument: expression(tokens)
            };
            break;
          }
        }
        break;
      }
      if (precedence === 0 && (assignment = tokens.match('strict assignment', 'lazy assignment', 'reset strict assignment', 'reset lazy assignment', 'inverse assignment', 'inheritance assignment'))) {
        if (assignment.type !== 'inheritance assignment' && assignment.type !== 'inverse assignment' && e.type !== 'identifier' && (e.type !== 'application' || assignment.type !== 'strict assignment' && assignment.type !== 'lazy assignment')) {
          parseError(assignment, 'Invalid left-hand side of assignment');
        }
        e = {
          type: 'assignment',
          operator: assignment.type,
          file: assignment.file,
          line: assignment.line,
          character: assignment.character,
          left: e,
          right: expression(tokens, 0, false, noIndent)
        };
      }
      return e;
    };
    value = function(tokens) {
      var e, patterns, t, values;
      if (tokens.match('group start')) {
        e = expression(tokens);
        tokens.require('group end');
        return e;
      }
      if (t = tokens.match('list start')) {
        values = [];
        if (!tokens.match('list end')) {
          while (true) {
            values.push(expression(tokens));
            if (tokens.match('list end')) {
              break;
            }
            tokens.require('list delimiter');
          }
        }
        return {
          file: t.file,
          line: t.line,
          character: t.character,
          type: 'list',
          values: values
        };
      }
      if (t = tokens.match('funject start')) {
        patterns = [];
        if (!tokens.match('funject end')) {
          if (tokens.match('indent')) {
            while (true) {
              patterns.push(pattern(tokens));
              if (tokens.match('outdent')) {
                break;
              }
              tokens.require('newline');
            }
            tokens.require('funject end');
          } else {
            patterns.push(pattern(tokens));
            tokens.require('funject end');
          }
        }
        return {
          file: t.file,
          line: t.line,
          character: t.character,
          type: 'funject',
          patterns: patterns
        };
      }
      if (tokens.here().type === 'identifier' && Object.prototype.hasOwnProperty.call(PREFIX_OPERATORS, tokens.here().value)) {
        t = tokens.advance();
        return {
          type: 'application',
          file: t.file,
          line: t.line,
          character: t.character,
          funject: expression(tokens, PREFIX_OPERATORS[t.value]),
          argument: {
            type: 'symbol',
            file: t.file,
            line: t.line,
            character: t.character,
            value: 'not'
          }
        };
      }
      if (t = tokens.match('identifier', 'formal parameter', 'symbol', 'string', 'number', 'boolean', 'nil', 'unknown')) {
        return t;
      }
    };
    pattern = function(tokens) {
      var match, result;
      match = expression(tokens);
      tokens.require('pattern match');
      result = expression(tokens);
      return {
        pattern: match,
        value: result
      };
    };
    return parse;
  })();

  parseForRacket = function(s) {
    var transform;
    transform = function(n) {
      var p, x;
      switch (n.type) {
        case 'number':
          return ['Token-number', n.value];
        case 'symbol':
          return ['Token-symbol', n.value];
        case 'string':
          return ['Token-string', n.value];
        case 'boolean':
          return ['Token-boolean', n.value];
        case 'nil':
          return ['Token-nil'];
        case 'unknown':
          return ['Token-unknown'];
        case 'identifier':
          return ['Token-identifier', n.value];
        case 'formal parameter':
          return ['Token-parameter', n.value];
        case 'list':
          return [
            'Token-list', (function() {
              var _i, _len, _ref, _results;
              _ref = n.values;
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                x = _ref[_i];
                _results.push(transform(x));
              }
              return _results;
            })()
          ];
        case 'funject':
          return [
            'Token-funject', (function() {
              var _i, _len, _ref, _results;
              _ref = n.patterns;
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                p = _ref[_i];
                _results.push([transform(p.pattern), transform(p.value)]);
              }
              return _results;
            })()
          ];
        case 'sequence':
          return [
            'Token-sequence', (function() {
              var _i, _len, _ref, _results;
              _ref = n.expressions;
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                x = _ref[_i];
                _results.push(transform(x));
              }
              return _results;
            })()
          ];
        case 'application':
          return ['Token-invocation', transform(n.funject), transform(n.argument)];
        case 'or':
        case 'and':
          return ['Token-' + n.type, transform(n.left), transform(n.right)];
        case 'class':
        case 'module':
          if (n.parent) {
            return ['Token-' + n.type, transform(n.parent), transform(n.body)];
          } else {
            return ['Token-' + n.type, transform(n.body)];
          }
          break;
        case 'try':
          if (n["finally"]) {
            return ['Token-try', transform(n.body), transform(n["catch"]), transform(n["finally"])];
          } else {
            return ['Token-try', transform(n.body), transform(n["catch"])];
          }
          break;
        case 'assignment':
          switch (n.operator) {
            case 'strict assignment':
              if (n.left.type === 'application') {
                return ['Token-funject-strict-assignment', transform(n.left), transform(n.right)];
              } else {
                return ['Token-strict-assignment', transform(n.left), transform(n.right)];
              }
              break;
            case 'lazy assignment':
              if (n.left.type === 'application') {
                return ['Token-funject-lazy-assignment', transform(n.left), transform(n.right)];
              } else {
                return ['Token-lazy-assignment', transform(n.left), transform(n.right)];
              }
              break;
            case 'reset strict assignment':
              return ['Token-reset-strict-assignment', transform(n.left), transform(n.right)];
            case 'reset lazy assignment':
              return ['Token-reset-lazy-assignment', transform(n.left), transform(n.right)];
            case 'inheritance assignment':
              return ['Token-funject-inheritance', transform(n.left), transform(n.right)];
            case 'inverse assignment':
              return ['Token-inverse-definition', transform(n.left), transform(n.right)];
          }
      }
    };
    return transform(parse(s));
  };

  printTokens = function(s) {
    var indent, t, tokens, _results;
    tokens = tokenizer(s);
    indent = '';
    _results = [];
    while (true) {
      t = tokens.advance();
      if (t.type === 'end') {
        break;
      }
      switch (t.type) {
        case 'indent':
          console.log("" + indent + "{");
          _results.push(indent += '    ');
          break;
        case 'outdent':
          indent = indent.substr(4);
          _results.push(console.log("" + indent + "}"));
          break;
        case 'newline':
          _results.push(console.log("" + indent + ";"));
          break;
        default:
          _results.push(console.log("" + indent + "(:" + t.line + ":" + t.character + ") <" + t.type + "> " + t.value));
      }
    }
    return _results;
  };

  printTree = function(s) {
    var print;
    print = function(n, indent) {
      var name, v, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results, _results1, _results2;
      if (indent == null) {
        indent = '';
      }
      if (n instanceof Array) {
        if (typeof n[0] === 'string') {
          name = n[0].replace(/^Token-/, '');
          if (n.length === 2 && typeof n[1] !== 'object') {
            return console.log("" + indent + name + ": " + n[1]);
          } else {
            console.log("" + indent + name);
            if (n[1] && typeof n[1][0] !== 'string') {
              _ref = n[1];
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                v = _ref[_i];
                _results.push(print(v, indent + '    '));
              }
              return _results;
            } else {
              _ref1 = n.slice(1);
              _results1 = [];
              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                v = _ref1[_j];
                _results1.push(print(v, indent + '    '));
              }
              return _results1;
            }
          }
        } else {
          console.log("" + indent + "pattern:");
          _ref2 = n.slice(0);
          _results2 = [];
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            v = _ref2[_k];
            _results2.push(print(v, indent + '    '));
          }
          return _results2;
        }
      } else {
        return console.log(indent + n);
      }
    };
    return print(parseForRacket(s));
  };

  stringify = function(n) {};

  if (typeof module !== "undefined" && module !== null) {
    _exports = exports;
    if (!module.parent) {
      expression = null;
      racket = false;
      i = 2;
      tokens = false;
      verbose = false;
      argc = process.argv.length;
      while (i < argc) {
        switch (arg = process.argv[i++]) {
          case '-r':
            racket = true;
            break;
          case '-t':
            tokens = true;
            break;
          case '-v':
            verbose = true;
            break;
          case '-e':
            expression = process.argv[i++];
            break;
          default:
            expression = '' + require('fs').readFileSync(arg);
            break;
        }
      }
      if (i < argc || (expression == null)) {
        console.error('Usage: coffee parser.coffee [ -r | -t | -v ] [ <filename> | -e <expression> ]');
        return;
      }
      try {
        if (tokens) {
          printTokens(expression);
        } else if (verbose || racket) {
          p = racket ? parseForRacket : parse;
          console.log(JSON.stringify(p(expression), void 0, 2));
        } else {
          printTree(expression);
        }
      } catch (_error) {
        e = _error;
        if (e instanceof SyntaxError) {
          console.error(e.message);
        } else {
          throw e;
        }
      }
    }
  } else {
    (this.Yak != null ? this.Yak : this.Yak = {}).parser = _exports = {};
  }

  _ref = {
    IDENTIFIER_CHARS: IDENTIFIER_CHARS,
    parse: parse,
    stringify: stringify,
    tokenizer: tokenizer,
    parseForRacket: parseForRacket
  };
  for (k in _ref) {
    v = _ref[k];
    _exports[k] = v;
  }

  environment = typeof global !== "undefined" && global !== null ? global : this;

  SPECIAL_FORM = {};

  NO_MATCH = {};

  last = function(thing) {
    return thing[thing.length - 1];
  };

  extend = function(object, properties) {
    var key, value;
    for (key in properties) {
      value = properties[key];
      object[key] = value;
    }
    return object;
  };

  equal = function(a, b) {
    var x, _i, _len;
    if (a.type !== b.type) {
      return false;
    }
    switch (a.type) {
      case 'list':
        if (a.value.length !== b.value.length) {
          return false;
        }
        for (i = _i = 0, _len = a.length; _i < _len; i = ++_i) {
          x = a[i];
          if (!equal(x, b[i])) {
            return false;
          }
        }
        return true;
      case 'funject':
        return a === b;
      case 'number':
      case 'boolean':
      case 'string':
      case 'symbol':
        return a.value === b.value;
      case 'nil':
      case 'unknown':
        return true;
    }
  };

  InterpreterError = (function() {
    function InterpreterError(message) {
      this.message = message;
    }

    return InterpreterError;

  })();

  UserError = (function() {
    function UserError(error) {
      this.error = error;
    }

    return UserError;

  })();

  RuntimeError = (function(_super) {
    __extends(RuntimeError, _super);

    function RuntimeError(message, trace) {
      this.message = message;
      this.trace = trace;
    }

    return RuntimeError;

  })(Error);

  MatchError = (function(_super) {
    __extends(MatchError, _super);

    function MatchError(funject, argument) {
      MatchError.__super__.constructor.call(this, "No match for " + funject + " applied to " + argument);
    }

    return MatchError;

  })(InterpreterError);

  Scope = (function() {
    function Scope(parent, vars, unnamed) {
      var name, value;
      this.parent = parent;
      if (unnamed == null) {
        unnamed = true;
      }
      this.vars = Object.create(null);
      if (vars != null) {
        for (name in vars) {
          value = vars[name];
          if (unnamed) {
            this.vars[name] = value;
          } else {
            this.set(name, value);
          }
        }
      }
    }

    Scope.prototype.get = function(name) {
      if (Object.prototype.hasOwnProperty.call(this.vars, name)) {
        return this.vars[name];
      }
      if (this.parent) {
        return this.parent.get(name);
      }
      throw new InterpreterError("Undefined variable " + name);
    };

    Scope.prototype.set = function(name, value) {
      if (this.isProxy) {
        return this.parent.set(name, value);
      } else {
        if (value.name == null) {
          value.name = name;
        }
        return this.vars[name] = value;
      }
    };

    Scope.prototype.reset = function(name, value) {
      if (Object.prototype.hasOwnProperty.call(this.vars, name)) {
        return this.vars[name] = value;
      }
      if (this.parent) {
        return this.parent.reset(name, value);
      }
      throw new InterpreterError("Cannot reset undefined variable " + name);
    };

    return Scope;

  })();

  Funject = (function() {
    Funject.prototype.type = 'funject';

    Funject.prototype.toString = function() {
      var s;
      try {
        s = new Interpreter().evaluate({
          type: 'application',
          funject: {
            type: 'value',
            value: this
          },
          argument: {
            type: 'symbol',
            value: 'to-string'
          }
        });
        if (s.isString) {
          return s.value;
        } else {
          return this.basicToString();
        }
      } catch (_error) {
        e = _error;
        if (e instanceof RuntimeError) {
          return this.basicToString();
        } else {
          throw e;
        }
      }
    };

    Funject.prototype.basicToString = function() {
      if (this.isClass) {
        if (this.name) {
          return "#<class " + this.name + ">";
        } else {
          return '#<class>';
        }
      } else if (this.call && this.call.length !== 0) {
        return '#<primitive>';
      } else {
        return '#<funject>';
      }
    };

    Funject.prototype.toSource = function(depth) {
      var s;
      if (depth === 0) {
        return this.basicToString();
      }
      try {
        s = new Interpreter().evaluate({
          type: 'application',
          funject: {
            type: 'value',
            value: this
          },
          argument: {
            type: 'symbol',
            value: 'inspect'
          }
        });
        if (s.isString) {
          return s.value;
        } else {
          return this.getSource();
        }
      } catch (_error) {
        e = _error;
        if (e instanceof RuntimeError) {
          return this.getSource(depth);
        } else {
          throw e;
        }
      }
    };

    Funject.prototype.getSource = function(depth) {
      if (depth === 0 || this.isClass || (this.call && this.call.length !== 0)) {
        return this.basicToString();
      } else if (!this.patterns || this.patterns.length === 0) {
        return '{}';
      } else {
        /*
        s = "{"
        for p in @patterns
            s += "\n    "
            s += parser.stringify p.pattern
            s += ": "
            s += (if p.expression
                parser.stringify p.expression
            else
                p.value.toSource depth - 1
            ).replace /\n/g, '\n    '
        s += "\n}"
        */

        return this.basicToString();
      }
    };

    function Funject(properties) {
      var key, value;
      this.patterns = [];
      if (properties) {
        for (key in properties) {
          value = properties[key];
          this[key] = value;
        }
      }
    }

    Funject.prototype.methodHasArgs = function() {
      var answer, hasArgs, length, method, o, pattern, _i, _len, _ref1;
      method = this;
      hasArgs = null;
      answer = function(result) {
        if ((hasArgs != null) && hasArgs !== result) {
          throw new InterpreterError('Method cannot match both [@self] and [@self, @arg]');
        }
        return hasArgs = result;
      };
      while (true) {
        if (method.call) {
          i = 0;
          length = method.call.length;
          while (i < length) {
            pattern = method.call[i++];
            while (pattern === 'own' || pattern === 'interpreter') {
              pattern = method.call[i++];
            }
            if (pattern instanceof Array) {
              if (pattern.length === 1) {
                answer(false);
              }
              if (pattern.length === 2) {
                answer(true);
              }
            }
            ++i;
          }
        }
        if (method.patterns) {
          _ref1 = method.patterns;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            o = _ref1[_i];
            p = o.pattern;
            if (p.type === 'list' && p.values.length === 1) {
              answer(false);
            }
            if (p.type === 'list' && p.values.length === 2) {
              answer(true);
            }
          }
        }
        if (hasArgs != null) {
          return hasArgs;
        }
        if (!(method = method.parent)) {
          throw new InterpreterError("" + this + " is not a method");
        }
      }
    };

    Funject.prototype.isKindOf = function(_class) {
      var inst;
      inst = this.instance;
      while (inst) {
        if (inst === _class.$instance) {
          return true;
        }
        inst = inst.parent;
      }
      return false;
    };

    Funject.prototype.isMemberOf = function(_class) {
      return this.instance === _class.$instance;
    };

    Funject.prototype.hasSymbol = function(name) {
      var method, _i, _j, _len, _len1, _ref1, _ref2;
      method = this;
      while (method) {
        if (method.call) {
          _ref1 = method.call;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            p = _ref1[_i];
            if (p === 'symbol' || p[0] === '.' && name === p.substr(1)) {
              return true;
            }
          }
        }
        if (method.patterns) {
          _ref2 = method.patterns;
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            p = _ref2[_j];
            if (p.pattern.type === 'formal parameter' || p.pattern.type === 'symbol' && p.pattern.value === name || p.pattern.type === 'identifier' && p.scope.get(p.pattern.value).isMemberOf(lang.Symbol)) {
              return true;
            }
          }
        }
        method = method.parent;
      }
      return false;
    };

    Funject.prototype.keys = function() {
      var length, pattern, result, _i, _len, _ref1,
        _this = this;
      pattern = function(p, scope) {
        switch (p.type) {
          case 'list':
            return new ListFunject((function() {
              var _i, _len, _ref1, _results;
              _ref1 = p.values;
              _results = [];
              for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                v = _ref1[_i];
                _results.push(pattern(v, scope));
              }
              return _results;
            })());
          case 'symbol':
            return yakSymbol(p.value);
          case 'string':
            return new StringFunject(p.value);
          case 'number':
            return new NumberFunject(p.value);
          case 'nil':
          case 'unknown':
            return lang[p.value];
          case 'identifier':
            return scope.get(p.value);
          default:
            throw new InterpreterError("" + _this + " has non-constant keys");
        }
      };
      result = [];
      if (this.patterns) {
        _ref1 = this.patterns;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          p = _ref1[_i];
          result.push(pattern(p.pattern, p.scope));
        }
      }
      if (this.call) {
        i = 0;
        length = this.call.length;
        while (i < length) {
          p = this.call[i++];
          while (p === 'interpreter' || p === 'own') {
            p = this.call[i++];
          }
          if (p[0] === '.') {
            result.push(yakSymbol(p.substr(1)));
          } else if (p[0] === '"') {
            result.push(new StringFunject(p.substr(1)));
          }
        }
      }
      return new ListFunject(result);
    };

    Funject.prototype.keysOf = function(c) {
      var result, _i, _len, _ref1;
      result = [];
      _ref1 = this.keys().value;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        k = _ref1[_i];
        if (k.isMemberOf(c)) {
          result.push(k);
        }
      }
      return new ListFunject(result);
    };

    Funject.prototype.allKeys = function() {
      var add, f, l, result, _i, _j, _len, _len1, _ref1;
      result = [];
      f = this;
      while (f) {
        _ref1 = f.keys().value;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          k = _ref1[_i];
          add = true;
          for (_j = 0, _len1 = result.length; _j < _len1; _j++) {
            l = result[_j];
            if (equal(l, k)) {
              add = false;
            }
          }
          if (add) {
            result.push(k);
          }
        }
        f = f.parent;
      }
      return new ListFunject(result);
    };

    Funject.prototype.isObject = function() {
      var _i, _len, _ref1;
      try {
        _ref1 = this.keys();
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          k = _ref1[_i];
          if (!k.isMemberOf(lang.Symbol)) {
            return false;
          }
        }
      } catch (_error) {
        e = _error;
        if (e instanceof InterpreterError) {
          return false;
        } else {
          throw e;
        }
      }
      return true;
    };

    Funject.prototype["native"] = function(pattern, argument) {
      var a, args, x, _i, _j, _len, _len1, _ref1, _ref2;
      if (pattern instanceof Array) {
        if (pattern[0] === '|') {
          _ref1 = pattern.slice(1);
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            p = _ref1[_i];
            if (args = this["native"](p, argument)) {
              return args;
            }
          }
          return false;
        }
        args = [];
        if (!argument.isList || pattern.length !== argument.value.length) {
          return false;
        }
        _ref2 = argument.value;
        for (i = _j = 0, _len1 = _ref2.length; _j < _len1; i = ++_j) {
          x = _ref2[i];
          if (a = this["native"](pattern[i], x)) {
            args = args.concat(a);
          } else {
            return false;
          }
        }
        return args;
      }
      if (pattern === '*') {
        return [argument];
      }
      if (lang[pattern]) {
        if (argument === lang[pattern]) {
          return [];
        } else {
          return false;
        }
      }
      if (typeof pattern === 'string') {
        if (pattern[0] === '.') {
          if (argument.isSymbol && argument.value === pattern.substr(1)) {
            return [];
          }
        } else if (pattern[0] === '"') {
          if (argument.isString && argument.value === pattern.substr(1)) {
            return [];
          }
        } else if (pattern[0] === '&') {
          if (argument === globalScope.get(pattern.substr(1))) {
            return [];
          }
        } else {
          if (argument.type === pattern) {
            return [argument];
          }
        }
        return false;
      }
    };

    Funject.prototype.scan = function(scope, bindings, applications, pattern, argument) {
      var sub, x, _i, _len, _ref1;
      if (pattern.type === 'list') {
        if (!(argument.isList && argument.value.length === pattern.values.length)) {
          return false;
        }
        _ref1 = pattern.values;
        for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
          x = _ref1[i];
          if (!(sub = this.scan(scope, bindings, applications, x, argument.value[i]))) {
            return false;
          }
        }
        return true;
      }
      if (pattern.type === 'formal parameter') {
        if (Object.prototype.hasOwnProperty.call(bindings, pattern.value)) {
          return equal(bindings[pattern.value], argument);
        }
        bindings[pattern.value] = argument;
        return true;
      }
      if (pattern.type === 'identifier') {
        return equal(argument, scope.get(pattern.value));
      }
      if (pattern.type === 'application') {
        applications.push({
          funject: pattern.funject,
          argument: pattern.argument,
          value: argument
        });
        return true;
      }
      if (pattern.type === 'number' || pattern.type === 'symbol' || pattern.type === 'string' || pattern.type === 'boolean') {
        return pattern.type === argument.type && pattern.value === argument.value && true;
      }
      if (pattern.type === 'nil' || pattern.type === 'unknown') {
        return pattern.type === argument.type && true;
      }
      throw new InterpreterError("Invalid pattern");
    };

    Funject.prototype.match = function(interpreter, bound, pattern, argument) {
      var bindings, sub, x, _i, _len, _ref1;
      if (pattern.type === 'list') {
        bindings = {};
        _ref1 = pattern.values;
        for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
          x = _ref1[i];
          if (!(sub = this.match(interpreter, bound, x, argument.value[i]))) {
            return false;
          }
          extend(bindings, sub);
        }
        return bindings;
      }
      if (pattern.type === 'application') {
        arg = interpreter.first().value[interpreter.frame.arg++];
        if (!arg.isList) {
          throw new InterpreterError('Invalid inverse');
        }
        if (!arg.value.length) {
          return false;
        }
        return this.bind(arg.value[0], pattern, {}, bound);
      }
      return {};
    };

    Funject.prototype.bind = function(value, pattern, bindings, bound) {
      var x, _i, _len, _ref1;
      if (pattern.type === 'list') {
        _ref1 = pattern.values;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          x = _ref1[_i];
          this.bind(value, x, bindings, bound);
        }
      } else if (pattern.type === 'formal parameter') {
        if (!Object.prototype.hasOwnProperty.call(bound, pattern.value)) {
          bindings[pattern.value] = value;
        }
      } else if (pattern.type === 'application') {
        this.bind(value, pattern.argument, bindings, bound);
      }
      return bindings;
    };

    Funject.prototype.substitute = function(bindings, argument) {
      var x;
      if (argument.type === 'list') {
        return new ListFunject((function() {
          var _i, _len, _ref1, _results;
          _ref1 = argument.values;
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            x = _ref1[_i];
            _results.push(this.substitute(bindings, x));
          }
          return _results;
        }).call(this));
      }
      if (argument.type === 'number') {
        return new NumberFunject(argument.value);
      }
      if (argument.type === 'string') {
        return new StringFunject(argument.value);
      }
      if (argument.type === 'symbol') {
        return yakSymbol(argument.value);
      }
      if (argument.type === 'formal parameter') {
        if (Object.prototype.hasOwnProperty.call(bindings, argument.value)) {
          return bindings[argument.value];
        }
        return lang.unknown;
      }
      if (argument.type === 'application') {
        throw new InterpreterError('Nested applications are unimplemented');
      }
      if (argument.type === 'boolean' || argument.type === 'nil' || argument.type === 'unknown') {
        return lang[argument.value];
      }
    };

    Funject.prototype.apply = function(interpreter, own, argument, _private, instance) {
      var a, applications, args, bindings, bound, exp, length, n, offset, pattern, provideInterpreter, provideSelf, result, scope, value, _i, _len, _ref1, _ref2, _ref3;
      if (instance == null) {
        instance = true;
      }
      if (this.call) {
        i = 0;
        length = this.call.length;
        while (i < length) {
          pattern = this.call[i++];
          if (provideInterpreter = pattern === 'interpreter') {
            pattern = this.call[i++];
          }
          if (provideSelf = pattern === 'own') {
            pattern = this.call[i++];
          }
          value = this.call[i++];
          if (args = this["native"](pattern, argument)) {
            if (provideSelf) {
              args.unshift(own);
            }
            if (provideInterpreter) {
              args.unshift(interpreter);
            }
            if (SPECIAL_FORM === (result = value.apply(this, args))) {
              return;
            }
            if (NO_MATCH !== result) {
              return interpreter["return"](result);
            }
          }
        }
      }
      if (this.patterns) {
        arg = (_ref1 = interpreter.frame.arg) != null ? _ref1 : 0;
        offset = (_ref2 = interpreter.frame.index) != null ? _ref2 : 0;
        _ref3 = this.patterns.slice(offset);
        for (i = _i = 0, _len = _ref3.length; _i < _len; i = ++_i) {
          p = _ref3[i];
          applications = [];
          if (interpreter.frame.bindings) {
            bindings = interpreter.frame.bindings;
            applications = interpreter.frame.applications;
            delete interpreter.frame.applications;
            delete interpreter.frame.bindings;
          } else {
            bindings = {};
            if (!this.scan(p.scope, bindings, applications, p.pattern, argument)) {
              continue;
            }
          }
          if (applications.length) {
            if (interpreter.frame.step === 'match') {
              if (!(bound = this.match(interpreter, bindings, p.pattern, argument))) {
                delete interpreter.frame.step;
                continue;
              }
              extend(bindings, bound);
            } else if (interpreter.frame.step === 'inverse') {
              n = interpreter.frame.expression;
              interpreter.pop();
              interpreter.stack.push({
                expression: {
                  line: n.line,
                  character: n.character,
                  type: 'reapply funject',
                  "private": _private,
                  funject: this,
                  argument: argument,
                  own: own,
                  instance: instance
                },
                "arguments": [],
                step: 'match',
                applications: applications,
                bindings: bindings,
                arg: arg,
                index: offset + i
              });
              interpreter.push({
                line: p.pattern.line,
                character: p.pattern.character,
                type: 'list',
                values: (function() {
                  var _j, _len1, _ref4, _results;
                  _ref4 = interpreter.first().value;
                  _results = [];
                  for (i = _j = 0, _len1 = _ref4.length; _j < _len1; i = ++_j) {
                    a = _ref4[i];
                    if (!a.inverse) {
                      throw new InterpreterError("" + a + " has no inverse");
                    }
                    _results.push({
                      type: 'application',
                      funject: {
                        type: 'value',
                        value: a.inverse
                      },
                      argument: {
                        type: 'value',
                        value: new ListFunject([applications[i].value, this.substitute(bindings, applications[i].argument)])
                      }
                    });
                  }
                  return _results;
                }).call(this)
              });
              return;
            } else {
              n = interpreter.frame.expression;
              interpreter.pop();
              interpreter.stack.push({
                expression: {
                  line: n.line,
                  character: n.character,
                  type: 'reapply funject',
                  "private": _private,
                  funject: this,
                  argument: argument,
                  own: own,
                  instance: instance
                },
                "arguments": [],
                step: 'inverse',
                applications: applications,
                bindings: bindings,
                arg: arg,
                index: offset + i
              });
              interpreter.push({
                line: p.pattern.line,
                character: p.pattern.character,
                type: 'list',
                values: (function() {
                  var _j, _len1, _results;
                  _results = [];
                  for (_j = 0, _len1 = applications.length; _j < _len1; _j++) {
                    a = applications[_j];
                    _results.push(a.funject);
                  }
                  return _results;
                })()
              });
              return;
            }
          }
          if (p.value) {
            return interpreter["return"](p.value);
          } else {
            interpreter.pop();
            scope = interpreter.scope;
            bindings.own = own;
            if (_private) {
              bindings["private"] = _private;
            }
            interpreter.scope = new Scope(p.scope, bindings, true);
            interpreter.push({
              type: 'set scope',
              scope: scope
            });
            interpreter.push(p.expression);
          }
          return;
        }
      }
      if (instance && argument.isSymbol && this.instance && this.instance.hasSymbol(argument.value)) {
        exp = interpreter.frame.expression;
        interpreter.pop();
        interpreter.pop();
        interpreter.push({
          type: 'native',
          value: function() {
            var hasArgs, method, _base;
            method = this.first();
            if (method.name == null) {
              method.name = 'instance.' + argument.value;
            }
            if (method.expression) {
              ((_base = this.frame).expression != null ? (_base = this.frame).expression : _base.expression = {}).file = method.expression.file;
              this.frame.expression.line = method.expression.line;
              this.frame.expression.character = method.expression.character;
            }
            hasArgs = method.methodHasArgs();
            this.callStack.pop();
            if (hasArgs) {
              return this["return"](new Funject({
                call: [
                  'interpreter', '*', function(interpreter, arg) {
                    interpreter.pop();
                    interpreter.push({
                      type: 'application',
                      file: exp != null ? exp.file : void 0,
                      line: exp != null ? exp.line : void 0,
                      character: exp != null ? exp.character : void 0,
                      "private": own["private"] != null ? own["private"] : own["private"] = new Funject,
                      funject: {
                        type: 'value',
                        value: method
                      },
                      argument: {
                        type: 'value',
                        value: new ListFunject([own, arg])
                      }
                    });
                    return SPECIAL_FORM;
                  }
                ]
              }));
            } else {
              this.pop();
              return this.push({
                type: 'application',
                file: exp != null ? exp.file : void 0,
                line: exp != null ? exp.line : void 0,
                character: exp != null ? exp.character : void 0,
                "private": own["private"] != null ? own["private"] : own["private"] = new Funject,
                funject: {
                  type: 'value',
                  value: method
                },
                argument: {
                  type: 'value',
                  value: new ListFunject([own])
                }
              });
            }
          }
        });
        interpreter.push({
          type: 'application',
          file: exp != null ? exp.file : void 0,
          line: exp != null ? exp.line : void 0,
          character: exp != null ? exp.character : void 0,
          funject: {
            type: 'value',
            value: this.instance
          },
          argument: {
            type: 'value',
            value: argument
          },
          instance: false
        });
        return;
      }
      if (this.parent && this.parent !== this) {
        return this.parent.apply(interpreter, own, argument, _private, instance);
      }
      interpreter.callStack.pop();
      throw new MatchError(own, argument);
    };

    Funject.bridge = function(v, context) {
      var x;
      if (context == null) {
        context = environment;
      }
      if (v == null) {
        return lang.nil;
      }
      if (v instanceof Array) {
        return new ListFunject((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = v.length; _i < _len; _i++) {
            x = v[_i];
            _results.push(Funject.bridge(x));
          }
          return _results;
        })());
      }
      switch (typeof v) {
        case 'number':
          return new NumberFunject(v);
        case 'string':
          return new StringFunject(v);
        case 'boolean':
          return lang[v];
        case 'function':
          return new Funject({
            bridged: v,
            call: [
              'list', function(list) {
                return Funject.bridge(v.apply(context, Funject.unbridge(list)));
              }, 'symbol', function(property) {
                if (property in v) {
                  return Funject.bridge(v[property.value], v);
                }
                return NO_MATCH;
              }
            ]
          });
        case 'object':
          return new Funject({
            bridged: v,
            call: [
              'symbol', function(property) {
                if (property in v) {
                  return Funject.bridge(v[property.value], v);
                }
                return NO_MATCH;
              }
            ]
          });
      }
    };

    Funject.unbridge = function(f) {
      var interpreter, o, _i, _j, _len, _len1, _ref1, _ref2, _results;
      if (f.bridged != null) {
        return f.bridged;
      }
      switch (f.type) {
        case 'nil':
          return null;
        case 'unknown':
          throw new InterpreterError("Cannot unbridge " + f.type);
          break;
        case 'number':
        case 'string':
        case 'boolean':
          return f.value;
        case 'symbol':
          throw new InterpreterError("Cannot unbridge symbols");
          break;
        case 'list':
          _ref1 = f.value;
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            v = _ref1[_i];
            _results.push(Funject.unbridge(v));
          }
          return _results;
          break;
        case 'funject':
          if (f.isObject()) {
            interpreter = new Interpreter();
            o = {};
            _ref2 = f.keysOf(lang.Symbol).value;
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
              k = _ref2[_j];
              o[k.value] = Funject.unbridge(interpreter.evaluate({
                type: 'application',
                funject: {
                  type: 'value',
                  value: f
                },
                argument: {
                  type: 'symbol',
                  value: k.value
                }
              }));
            }
            return o;
          } else {
            return function() {
              return Funject.unbridge(new Interpreter().evaluate({
                type: 'application',
                funject: {
                  type: 'value',
                  value: f
                },
                argument: {
                  type: 'value',
                  value: Funject.bridge([].slice.call(arguments))
                }
              }));
            };
          }
      }
    };

    return Funject;

  })();

  yakObject = function(parent, properties, Type) {
    var call, _fn;
    if (Type == null) {
      Type = Funject;
    }
    call = [];
    if (properties) {
      _fn = function(v) {
        return call.push('.' + k, function() {
          return v;
        });
      };
      for (k in properties) {
        v = properties[k];
        _fn(v);
      }
    }
    return new Type({
      call: call,
      parent: parent
    });
  };

  yakFunction = function(pattern, value) {
    return new Funject({
      call: [pattern, value]
    });
  };

  yakClass = function(name, extend, _arg) {
    var cast, exports, instance, methods, result, _instance, _ref1, _ref2;
    _ref1 = _arg != null ? _arg : {}, exports = _ref1.exports, instance = _ref1.instance, _instance = _ref1._instance;
    methods = _instance != null ? _instance : yakObject(extend != null ? extend.$instance : void 0, instance);
    methods.isInstance = true;
    result = yakObject(extend, exports != null ? exports : {}, ClassFunject);
    if (extend == null) {
      delete result.parent;
    }
    result.$instance = methods;
    result.$super = extend;
    result.$subclasses = new ListFunject([]);
    if (extend) {
      extend.$subclasses.value.push(result);
    }
    result.instance = ((_ref2 = lang.Class) != null ? _ref2 : result).$instance;
    result.name = name;
    cast = 'to-' + name.toLowerCase();
    (result.call != null ? result.call : result.call = []).unshift('interpreter', ['*'], function(interpreter, x) {
      return {
        lazy: {
          type: 'application',
          funject: {
            type: 'value',
            value: x
          },
          argument: {
            type: 'symbol',
            value: cast
          }
        }
      };
    });
    result.inverse = new Funject({
      call: [
        ['*', ['unknown']], function(x) {
          var inst;
          inst = x.instance;
          while (inst) {
            if (inst === methods) {
              return new ListFunject([x]);
            }
            inst = inst.parent;
          }
          return new ListFunject([]);
        }
      ]
    });
    lang[name] = result;
    return result;
  };

  yakBoolean = function(value) {
    return lang[!!value];
  };

  yakSymbol = function(value) {
    if (Object.prototype.hasOwnProperty.call(SymbolFunject.instances, value)) {
      return SymbolFunject.instances[value];
    } else {
      return SymbolFunject.instances[value] = new SymbolFunject(value);
    }
  };

  lang = {};

  BaseFunject = yakObject(null, {
    initialize: yakFunction(['*'], function(x) {
      return lang.nil;
    }),
    'append!': yakFunction(['*', ['*', '*']], function(x, k, v) {
      (x.patterns != null ? x.patterns : x.patterns = []).push({
        pattern: {
          type: 'identifier',
          value: 'k'
        },
        scope: new Scope(null, {
          k: k
        }),
        value: v
      });
      return lang.nil;
    }),
    'insert!': yakFunction(['*', ['number', '*', '*']], function(x, i, k, v) {
      i = i.value;
      if (i < 0) {
        i = x.patterns ? x.patterns.length + i : i;
      }
      if (i % 1 !== 0 || i < 0 || (x.patterns ? i > x.patterns.length : i > 0)) {
        throw new InterpreterError("Cannot insert at " + i);
      }
      (x.patterns != null ? x.patterns : x.patterns = []).splice(i, 0, {
        pattern: {
          type: 'identifier',
          value: 'k'
        },
        scope: new Scope(null, {
          k: k
        }),
        value: v
      });
      return lang.nil;
    }),
    clone: yakFunction(['*'], function(x) {
      return new Funject({
        parent: x
      });
    }),
    name: yakFunction(['*'], function(x) {
      if (x.name) {
        return new StringFunject(x.name);
      } else {
        return lang.nil;
      }
    }),
    apply: new Funject({
      call: [
        'interpreter', ['*', ['*']], function(interpreter, f, x) {
          interpreter.pop();
          interpreter.push({
            type: 'application',
            funject: {
              type: 'value',
              value: f
            },
            argument: {
              type: 'value',
              value: x
            }
          });
          return SPECIAL_FORM;
        }
      ]
    }),
    on: new Funject({
      call: [
        'interpreter', ['*', '*'], function(interpreter, x, y) {
          interpreter.pop();
          interpreter.push({
            type: 'application',
            funject: {
              type: 'value',
              value: y
            },
            argument: {
              type: 'value',
              value: x
            }
          });
          return SPECIAL_FORM;
        }
      ]
    }),
    then: new Funject({
      call: [
        'interpreter', ['*', ['*']], function(interpreter, x, y) {
          interpreter.pop();
          interpreter.push({
            type: 'application',
            funject: {
              type: 'value',
              value: y
            },
            argument: {
              type: 'value',
              value: x
            }
          });
          return SPECIAL_FORM;
        }
      ]
    }),
    is: yakFunction(['*', '*'], function(x, y) {
      return yakBoolean(x === y);
    }),
    isnt: yakFunction(['*', '*'], function(x, y) {
      return yakBoolean(x !== y);
    }),
    '==': yakFunction(['*', '*'], function(x, y) {
      return yakBoolean(equal(x, y));
    }),
    '!=': yakFunction(['*', '*'], function(x, y) {
      return yakBoolean(!equal(x, y));
    }),
    'symbol?': yakFunction(['*'], function(x) {
      return yakBoolean(x.isSymbol);
    }),
    'string?': yakFunction(['*'], function(x) {
      return yakBoolean(x.isString);
    }),
    'number?': yakFunction(['*'], function(x) {
      return yakBoolean(x.isNumber);
    }),
    'list?': yakFunction(['*'], function(x) {
      return yakBoolean(x.isList);
    }),
    'boolean?': yakFunction(['*'], function(x) {
      return yakBoolean(x.isBoolean);
    }),
    'nil?': yakFunction(['*'], function(x) {
      return yakBoolean(x.isNil);
    }),
    'unknown?': yakFunction(['*'], function(x) {
      return yakBoolean(x.isUnknown);
    }),
    'class?': yakFunction(['*'], function(x) {
      return yakBoolean(x.isClass);
    }),
    'integer?': yakFunction(['*'], function(x) {
      return yakBoolean(x.isNumber && x.isInteger());
    }),
    'float?': yakFunction(['*'], function(x) {
      return yakBoolean(x.isNumber && x.isFloat());
    }),
    'member-of?': yakFunction(['*', ['class']], function(x, c) {
      return yakBoolean(x.isMemberOf(c));
    }),
    'kind-of?': yakFunction(['*', ['class']], function(x, c) {
      return yakBoolean(x.isKindOf(c));
    }),
    'to-string': yakFunction(['*'], function(x) {
      if (x.type === 'funject' || x.type === 'class') {
        return new StringFunject(Funject.prototype.basicToString.call(x));
      } else {
        return new StringFunject('' + x);
      }
    }),
    'to-symbol': yakFunction(['*'], function(x) {
      return yakSymbol(x + '');
    }),
    'to-boolean': yakFunction(['*'], function(x) {
      return yakBoolean(x !== lang.nil && x !== lang.unknown && x !== lang["false"]);
    }),
    'to-number': yakFunction(['*'], function(x) {
      var s;
      s = x + '';
      if (+s !== +s) {
        throw new InterpreterError("Cannot convert " + x + " to a number");
      }
      return new NumberFunject(+s);
    }),
    'to-error': new Funject({
      call: [
        'interpreter', ['*'], function(interpreter, s) {
          return interpreter.createError('' + s);
        }
      ]
    }),
    inspect: yakFunction(['*'], function(x) {
      if (x.type === 'funject' || x.type === 'class') {
        return new StringFunject(x.getSource(-1));
      } else {
        return new StringFunject(x.toSource());
      }
    }),
    'has?': yakFunction(['*', ['*']], function(f, key) {
      var _i, _len, _ref1;
      _ref1 = f.keys().value;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        k = _ref1[_i];
        if (equal(k, key)) {
          return lang["true"];
        }
      }
      return lang["false"];
    }),
    keys: yakFunction(['*'], function(f) {
      return f.keys();
    }),
    'keys-of': yakFunction(['*', ['class']], function(f, c) {
      return f.keysOf(c);
    }),
    'all-keys': yakFunction(['*'], function(f) {
      return f.allKeys();
    }),
    each: new Funject({
      call: [
        'interpreter', ['funject', ['funject']], function(interpreter, f, iterator) {
          var end, keys, next;
          next = function() {
            return interpreter.push({
              type: 'application',
              funject: {
                type: 'value',
                value: iterator
              },
              argument: {
                type: 'list',
                values: [
                  {
                    type: 'value',
                    value: keys[i]
                  }, {
                    type: 'application',
                    funject: {
                      type: 'value',
                      value: f
                    },
                    argument: {
                      type: 'value',
                      value: keys[i]
                    }
                  }
                ]
              }
            });
          };
          i = 0;
          keys = f.keys().value;
          end = keys.length;
          if (end === 0) {
            return lang.nil;
          }
          interpreter.pop();
          interpreter.push({
            type: 'native',
            value: function() {
              ++i;
              if (i === end) {
                return this["return"](new ListFunject(this.frame["arguments"]));
              }
              return next();
            }
          });
          next();
          return SPECIAL_FORM;
        }
      ]
    })
  });

  Funject.prototype.instance = BaseFunject;

  BaseFunject.instance = null;

  ClassFunject = (function(_super) {
    __extends(ClassFunject, _super);

    function ClassFunject() {
      _ref1 = ClassFunject.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    ClassFunject.prototype.type = 'class';

    ClassFunject.prototype.isClass = true;

    ClassFunject.prototype.create = function() {
      return new Funject({
        instance: this.$instance
      });
    };

    return ClassFunject;

  })(Funject);

  ListFunject = (function(_super) {
    __extends(ListFunject, _super);

    ListFunject.prototype.type = 'list';

    ListFunject.prototype.isList = true;

    ListFunject.prototype.copy = function() {
      return new ListFunject(this.value);
    };

    function ListFunject(value) {
      this.value = value;
    }

    ListFunject.prototype.toString = function() {
      return "[" + (((function() {
        var _i, _len, _ref2, _results;
        _ref2 = this.value;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          v = _ref2[_i];
          _results.push(v.toSource(4));
        }
        return _results;
      }).call(this)).join(', ')) + "]";
    };

    ListFunject.prototype.toSource = function(depth) {
      if (depth <= 0) {
        return "[...]";
      } else {
        return "[" + (((function() {
          var _i, _len, _ref2, _results;
          _ref2 = this.value;
          _results = [];
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            v = _ref2[_i];
            _results.push(v.toSource(depth - 1));
          }
          return _results;
        }).call(this)).join(', ')) + "]";
      }
    };

    ListFunject.prototype.call = [
      'own', ['number'], function(self, n) {
        i = n.value < 0 ? self.value.length + n.value : n.value;
        if (i < 0 || i >= self.value.length) {
          throw new InterpreterError("Cannot access " + self + " at " + n);
        }
        return self.value[i];
      }, '.class', function() {
        return lang.List;
      }
    ];

    return ListFunject;

  })(Funject);

  yakClass('Class', null, {
    instance: {
      superclass: yakFunction(['class'], function(f) {
        var _ref2;
        return (_ref2 = f.$super) != null ? _ref2 : lang.nil;
      }),
      subclasses: yakFunction(['class'], function(f) {
        return f.$subclasses.copy();
      }),
      instance: yakFunction(['class'], function(f) {
        return f.$instance;
      }),
      methods: yakFunction(['class'], function(f) {
        return f.$instance.keysOf(lang.Symbol);
      }),
      'all-methods': yakFunction(['class'], function(f) {
        return f.$instance.allKeys(true);
      })
    }
  });

  ClassFunject.prototype.parent = yakObject(null, {
    "class": lang.Class
  });

  ClassFunject.prototype.instance = lang.Class.$instance;

  lang.Class.$instance.parent = BaseFunject;

  yakClass('Funject', null, {
    _instance: BaseFunject
  });

  lang.Class.$super = lang.Funject;

  lang.Funject.$subclasses.value.push(lang.Class);

  Funject.prototype.parent = yakObject(null, {
    "class": lang.Funject
  });

  yakClass('Symbol', lang.Funject, {
    instance: {}
  });

  yakClass('String', lang.Funject, {
    instance: {
      initialize: yakFunction(['string', ['string']], function(self, s) {
        if (self.value != null) {
          throw new InterpreterError("" + self + " is immutable");
        }
        return self.value = s.value;
      }),
      length: yakFunction(['string'], function(s) {
        return new NumberFunject(s.value.length);
      }),
      '+': new Funject({
        call: [
          ['string', 'string'], function(x, y) {
            return new StringFunject(x.value + y.value);
          }
        ],
        inverse: new Funject({
          call: [
            ['string', ['unknown', 'string']], function(s, x) {
              if (x.value !== s.value.slice(-x.value.length)) {
                return new ListFunject([]);
              } else {
                return new ListFunject([new StringFunject(s.value.slice(0, -x.value.length))]);
              }
            }, ['string', ['string', 'unknown']], function(s, x) {
              if (x.value !== s.value.slice(0, x.value.length)) {
                return new ListFunject([]);
              } else {
                return new ListFunject([new StringFunject(s.value.slice(x.value.length))]);
              }
            }
          ]
        })
      }),
      '*': yakFunction(['string', 'number'], function(s, n) {
        return s.repeat(n);
      }),
      'contains?': yakFunction(['string', ['string']], function(self, s) {
        return yakBoolean(-1 !== self.value.indexOf(s.value));
      }),
      'replace': yakFunction(['string', ['string', 'string']], function(self, x, y) {
        return new StringFunject(self.value.split(x.value).join(y.value));
      }),
      'replace-first': yakFunction(['string', ['string', 'string']], function(self, x, y) {
        return new StringFunject(self.value.replace(x.value, y.value));
      })
    }
  });

  integerIdentityInverse = new Funject({
    call: [
      ['number', ['unknown']], function(x) {
        if (x.isInteger()) {
          return new ListFunject([x]);
        } else {
          return new ListFunject([]);
        }
      }
    ]
  });

  yakClass('Number', lang.Funject, {
    exports: {
      random: new Funject({
        call: [
          [], function() {
            return new NumberFunject(Math.random());
          }, ['number'], function(x) {
            if (!x.isInteger()) {
              throw new InterpreterError("Cannot generate random[" + x + "]");
            }
            return new NumberFunject(Math.floor(Math.random() * x.value));
          }, ['number', 'number'], function(x, y) {
            if (!x.isInteger() || !y.isInteger() || y.value <= x.value) {
              throw new InterpreterError("Cannot generate random[" + x + ", " + y + "]");
            }
            return new NumberFunject(x.value + Math.floor(Math.random() * (y.value - x.value)));
          }
        ]
      })
    },
    instance: {
      'degrees-to-radians': yakFunction(['number'], function(x) {
        return new NumberFunject(x.value * Math.PI / 180);
      }),
      'radians-to-degrees': yakFunction(['number'], function(x) {
        return new NumberFunject(x.value * 180 / Math.PI);
      }),
      max: yakFunction(['number', ['number']], function(x, y) {
        return new NumberFunject((x.value > y.value ? x.value : y.value));
      }),
      min: yakFunction(['number', ['number']], function(x, y) {
        return new NumberFunject((x.value < y.value ? x.value : y.value));
      }),
      sqrt: yakFunction(['number'], function(x) {
        if (x.value < 0) {
          throw new InterpreterError("Cannot compute " + x + ".sqrt");
        }
        return new NumberFunject(Math.sqrt(x.value));
      }),
      root: yakFunction(['number', ['number']], function(x, y) {
        return new NumberFunject(Math.pow(x.value, 1 / y.value));
      }),
      ln: yakFunction(['number'], function(x) {
        return new NumberFunject(Math.log(x.value));
      }),
      log: yakFunction(['number', ['number']], function(x, b) {
        return new NumberFunject(Math.log(x.value) / Math.log(b.value));
      }),
      sin: yakFunction(['number'], function(x) {
        return new NumberFunject(Math.sin(x.value));
      }),
      cos: yakFunction(['number'], function(x) {
        return new NumberFunject(Math.cos(x.value));
      }),
      tan: yakFunction(['number'], function(x) {
        return new NumberFunject(Math.tan(x.value));
      }),
      sec: yakFunction(['number'], function(x) {
        return new NumberFunject(1 / Math.cos(x.value));
      }),
      csc: yakFunction(['number'], function(x) {
        return new NumberFunject(1 / Math.sin(x.value));
      }),
      cot: yakFunction(['number'], function(x) {
        return new NumberFunject(1 / Math.tan(x.value));
      }),
      asin: yakFunction(['number'], function(x) {
        return new NumberFunject(Math.asin(x.value));
      }),
      acos: yakFunction(['number'], function(x) {
        return new NumberFunject(Math.acos(x.value));
      }),
      atan: yakFunction(['number'], function(x) {
        return new NumberFunject(Math.atan(x.value));
      }),
      'atan/': yakFunction(['number', ['number']], function(y, x) {
        return new NumberFunject(Math.atan2(y.value, x.value));
      }),
      asec: yakFunction(['number'], function(x) {
        return new NumberFunject(Math.acos(1 / x));
      }),
      acsc: yakFunction(['number'], function(x) {
        return new NumberFunject(Math.asin(1 / x));
      }),
      acot: yakFunction(['number'], function(x) {
        return new NumberFunject(Math.atan(1 / x));
      }),
      sinh: yakFunction(['number'], function(x) {
        return new NumberFunject((Math.exp(x.value) - Math.exp(-x.value)) / 2);
      }),
      cosh: yakFunction(['number'], function(x) {
        return new NumberFunject((Math.exp(x.value) + Math.exp(-x.value)) / 2);
      }),
      tanh: yakFunction(['number'], function(x) {
        return new NumberFunject((Math.exp(x.value * 2) - 1) / (Math.exp(x.value * 2) + 1));
      }),
      coth: yakFunction(['number'], function(x) {
        return new NumberFunject((Math.exp(x.value * 2) + 1) / (Math.exp(x.value * 2) - 1));
      }),
      sech: yakFunction(['number'], function(x) {
        return new NumberFunject(2 / (Math.exp(x.value) + Math.exp(-x.value)));
      }),
      csch: yakFunction(['number'], function(x) {
        return new NumberFunject(2 / (Math.exp(x.value) - Math.exp(-x.value)));
      }),
      asinh: yakFunction(['number'], function(x) {
        return new NumberFunject(Math.log(x.value + Math.sqrt(x.value * x.value + 1)));
      }),
      acosh: yakFunction(['number'], function(x) {
        return new NumberFunject(Math.log(x.value + Math.sqrt(x.value * x.value - 1)));
      }),
      atanh: yakFunction(['number'], function(x) {
        return new NumberFunject(Math.log((1 + x.value) / (1 - x.value)) / 2);
      }),
      acoth: yakFunction(['number'], function(x) {
        return new NumberFunject(Math.log((1 - x.value) / (1 + x.value)) / 2);
      }),
      asech: yakFunction(['number'], function(x) {
        return new NumberFunject(Math.log(1 / x.value + Math.sqrt(1 - x.value * x.value) / x.value));
      }),
      acsch: yakFunction(['number'], function(x) {
        return new NumberFunject(Math.log(1 / x.value + Math.sqrt(1 + x.value * x.value) / Math.abs(x.value)));
      }),
      abs: new Funject({
        call: [
          ['number'], function(x) {
            return new NumberFunject(x.value < 0 ? -x.value : x.value);
          }
        ],
        inverse: new Funject({
          call: [
            ['number', ['unknown']], function(x) {
              return new ListFunject([new NumberFunject(x.value), new NumberFunject(-x.value)]);
            }
          ]
        })
      }),
      ceil: new Funject({
        call: [
          ['number'], function(x) {
            return new NumberFunject(Math.ceil(x.value));
          }
        ],
        inverse: integerIdentityInverse
      }),
      floor: new Funject({
        call: [
          ['number'], function(x) {
            return new NumberFunject(Math.floor(x.value));
          }
        ],
        inverse: integerIdentityInverse
      }),
      round: new Funject({
        call: [
          ['number'], function(x) {
            return new NumberFunject(Math.round(x.value));
          }
        ],
        inverse: integerIdentityInverse
      }),
      'to-fixed': new Funject({
        call: [
          ['number', ['number']], function(x, y) {
            if (y.value < 0 || y.value > 20) {
              throw new InterpreterError("Cannot convert " + x + ".to-fixed[" + y + "]");
            }
            return new StringFunject(x.value.toFixed(y.value));
          }
        ],
        inverse: integerIdentityInverse
      }),
      'to-pennies': new Funject({
        call: [
          ['number'], function(x) {
            return new NumberFunject(Math.round(x.value * 100));
          }
        ],
        inverse: new Funject({
          call: [
            ['number', ['unknown']], function(x) {
              if (x.isInteger()) {
                return new ListFunject([new NumberFunject(Math.round(x.value) / 100)]);
              } else {
                return new ListFunject([]);
              }
            }
          ]
        })
      }),
      'to-dollars': new Funject({
        call: [
          ['number'], function(x) {
            return new NumberFunject(Math.round(x.value) / 100);
          }
        ],
        inverse: new Funject({
          call: [
            ['number', ['unknown']], function(x) {
              if (x.isInteger()) {
                return new ListFunject([new NumberFunject(Math.round(x.value) / 100)]);
              } else {
                return new ListFunject([]);
              }
            }
          ]
        })
      }),
      times: new Funject({
        call: [
          'interpreter', ['number', ['*']], function(interpreter, x, f) {
            var end;
            if (!x.isInteger() || x.value < 0) {
              throw new InterpreterError("Cannot " + x + ".times[...]");
            }
            i = 0;
            end = x.value;
            if (end === 0) {
              return new ListFunject([]);
            }
            interpreter.pop();
            interpreter.push({
              type: 'native',
              value: function() {
                ++i;
                if (i === end) {
                  return this["return"](new ListFunject(this.frame["arguments"]));
                }
                return this.push({
                  type: 'application',
                  funject: {
                    type: 'value',
                    value: f
                  },
                  argument: {
                    type: 'value',
                    value: new ListFunject([new NumberFunject(i)])
                  }
                });
              }
            });
            interpreter.push({
              type: 'application',
              funject: {
                type: 'value',
                value: f
              },
              argument: {
                type: 'value',
                value: new ListFunject([new NumberFunject(i)])
              }
            });
            return SPECIAL_FORM;
          }
        ]
      }),
      upto: yakFunction(['number', ['number']], function(x, y) {
        if (y.value < x.value) {
          return new ListFunject([]);
        } else {
          return new ListFunject((function() {
            var _i, _ref2, _ref3, _results;
            _results = [];
            for (i = _i = _ref2 = x.value, _ref3 = y.value; _ref2 <= _ref3 ? _i <= _ref3 : _i >= _ref3; i = _ref2 <= _ref3 ? ++_i : --_i) {
              _results.push(new NumberFunject(i));
            }
            return _results;
          })());
        }
      }),
      downto: yakFunction(['number', ['number']], function(x, y) {
        if (y.value > x.value) {
          return new ListFunject([]);
        } else {
          return new ListFunject((function() {
            var _i, _ref2, _ref3, _results;
            _results = [];
            for (i = _i = _ref2 = x.value, _ref3 = y.value; _ref2 <= _ref3 ? _i <= _ref3 : _i >= _ref3; i = _ref2 <= _ref3 ? ++_i : --_i) {
              _results.push(new NumberFunject(i));
            }
            return _results;
          })());
        }
      }),
      '+': new Funject({
        call: [
          ['number', 'number'], function(x, y) {
            return new NumberFunject(x.value + y.value);
          }
        ],
        inverse: new Funject({
          call: [
            ['number', ['|', ['number', 'unknown'], ['unknown', 'number']]], function(r, x) {
              return new ListFunject([new NumberFunject(r.value - x.value)]);
            }
          ]
        })
      }),
      '-': new Funject({
        call: [
          ['number', 'number'], function(x, y) {
            return new NumberFunject(x.value - y.value);
          }
        ],
        inverse: new Funject({
          call: [
            ['number', ['number', 'unknown']], function(r, x) {
              return new ListFunject([new NumberFunject(x.value - r.value)]);
            }, ['number', ['unknown', 'number']], function(r, x) {
              return new ListFunject([new NumberFunject(r.value + x.value)]);
            }
          ]
        })
      }),
      '*': new Funject({
        call: [
          ['number', 'number'], function(x, y) {
            return new NumberFunject(x.value * y.value);
          }, ['number', 'string'], function(n, s) {
            return s.repeat(n);
          }
        ],
        inverse: new Funject({
          call: [
            ['number', ['|', ['number', 'unknown'], ['unknown', 'number']]], function(r, x) {
              return new ListFunject([new NumberFunject(r.value / x.value)]);
            }
          ]
        })
      }),
      '/': new Funject({
        call: [
          ['number', 'number'], function(x, y) {
            return new NumberFunject(x.value / y.value);
          }
        ],
        inverse: new Funject({
          call: [
            ['number', ['number', 'unknown']], function(r, x) {
              return new ListFunject([new NumberFunject(x.value / r.value)]);
            }, ['number', ['unknown', 'number']], function(r, x) {
              return new ListFunject([new NumberFunject(r.value * x.value)]);
            }
          ]
        })
      }),
      '%': yakFunction(['number', 'number'], function(x, y) {
        var result;
        result = x.value % y.value;
        if (result < 0) {
          result += y.value;
        }
        return new NumberFunject(result);
      }),
      '^': new Funject({
        call: [
          ['number', 'number'], function(x, y) {
            return new NumberFunject(Math.pow(x.value, y.value));
          }
        ],
        inverse: new Funject({
          call: [
            ['number', ['number', 'unknown']], function(r, x) {
              return new ListFunject([new NumberFunject(Math.log(r.value) / Math.log(x.value))]);
            }, ['number', ['unknown', 'number']], function(r, x) {
              return new ListFunject([new NumberFunject(Math.pow(r.value, 1 / x.value))]);
            }
          ]
        })
      }),
      '>': yakFunction(['number', 'number'], function(x, y) {
        return yakBoolean(x.value > y.value);
      }),
      '<': yakFunction(['number', 'number'], function(x, y) {
        return yakBoolean(x.value < y.value);
      }),
      '>=': yakFunction(['number', 'number'], function(x, y) {
        return yakBoolean(x.value >= y.value);
      }),
      '<=': yakFunction(['number', 'number'], function(x, y) {
        return yakBoolean(x.value <= y.value);
      })
    }
  });

  lang.Number.call.unshift('.e', function() {
    return new NumberFunject(Math.E);
  }, '.pi', function() {
    return new NumberFunject(Math.PI);
  });

  yakClass('List', lang.Funject, {
    instance: {
      'to-list': yakFunction(['list'], function(x) {
        return x;
      }),
      'empty?': yakFunction(['list'], function(x) {
        return yakBoolean(x.value.length === 0);
      }),
      length: yakFunction(['list'], function(x) {
        return new NumberFunject(x.value.length);
      }),
      copy: yakFunction(['list'], function(x) {
        return new ListFunject(x.value.slice(0));
      }),
      'delete-at!': yakFunction(['list', ['number']], function(x, i) {
        if (i < 0) {
          i += x.value.length;
        }
        if (i < 0 && i >= x.value.length) {
          throw new InterpreterError("Cannot delete at " + i + " of " + x);
        }
        x.value.splice(i, 1);
        return x;
      }),
      'insert!': yakFunction(['list', ['number', '*']], function(x, i, e) {
        i = i.value;
        if (i < 0) {
          i += x.value.length;
        }
        if (i < 0 && i > x.value.length) {
          throw new InterpreterError("Cannot insert at " + i + " of " + x);
        }
        x.value.splice(i, 0, e);
        return x;
      }),
      'sort!': new Funject({
        call: [
          ['list', []], function(x) {
            x.value.sort(function(a, b) {
              return ('' + a).localeCompare('' + b);
            });
            return x;
          }, 'interpreter', ['list', ['funject']], function(interpreter, x, f) {
            var end, list;
            i = 0;
            list = x.value.slice(0);
            end = list.length;
            if (end === 0) {
              return new ListFunject([]);
            }
            interpreter.pop();
            interpreter.push({
              type: 'native',
              value: function() {
                var xs;
                ++i;
                if (i === end) {
                  xs = this.frame["arguments"];
                  list.sort(function(a, b) {
                    return xs[list.indexOf(a)] - xs[list.indexOf(b)];
                  });
                  x.value = list;
                  return this["return"](x);
                }
                return this.push({
                  type: 'application',
                  funject: {
                    type: 'value',
                    value: f
                  },
                  argument: {
                    type: 'value',
                    value: new ListFunject([list[i]])
                  }
                });
              }
            });
            interpreter.push({
              type: 'application',
              funject: {
                type: 'value',
                value: f
              },
              argument: {
                type: 'value',
                value: new ListFunject([list[i]])
              }
            });
            return SPECIAL_FORM;
          }
        ]
      }),
      'map!': new Funject({
        call: [
          'interpreter', ['list', ['funject']], function(interpreter, x, f) {
            var end, list;
            i = 0;
            list = x.value.slice(0);
            end = list.length;
            if (end === 0) {
              return x;
            }
            interpreter.pop();
            interpreter.push({
              type: 'native',
              value: function() {
                while (true) {
                  if (!this.arg(i, {
                    type: 'application',
                    funject: {
                      type: 'value',
                      value: f
                    },
                    argument: {
                      type: 'value',
                      value: new ListFunject([list[i]])
                    }
                  })) {
                    return;
                  }
                  ++i;
                  if (i === end) {
                    x.value = this.frame["arguments"];
                    return this["return"](x);
                  }
                }
              }
            });
            return SPECIAL_FORM;
          }
        ]
      }),
      'filter!': new Funject({
        call: [
          'interpreter', ['list', ['funject']], function(interpreter, x, f) {
            var end, list, result;
            i = 0;
            list = x.value.slice(0);
            end = list.length;
            if (end === 0) {
              return x;
            }
            result = [];
            interpreter.pop();
            interpreter.push({
              type: 'native',
              value: function() {
                var include;
                while (true) {
                  if (!this.arg(i, {
                    type: 'application',
                    funject: {
                      type: 'value',
                      value: f
                    },
                    argument: {
                      type: 'value',
                      value: new ListFunject([list[i]])
                    }
                  })) {
                    return;
                  }
                  include = this.frame["arguments"][this.frame["arguments"].length - 1];
                  if (!include.isBoolean) {
                    throw new InterpreterError("Cannot filter on " + include);
                  }
                  if (include.value) {
                    result.push(list[i]);
                  }
                  ++i;
                  if (i === end) {
                    return this["return"](new ListFunject(result));
                  }
                }
              }
            });
            return SPECIAL_FORM;
          }
        ]
      }),
      each: new Funject({
        call: [
          'interpreter', ['list', ['funject']], function(interpreter, x, f) {
            var end, list;
            i = 0;
            list = x.value.slice(0);
            end = list.length;
            if (end === 0) {
              return lang.nil;
            }
            interpreter.pop();
            interpreter.push({
              type: 'native',
              value: function() {
                while (true) {
                  if (!this.arg(i, {
                    type: 'application',
                    funject: {
                      type: 'value',
                      value: f
                    },
                    argument: {
                      type: 'value',
                      value: new ListFunject([list[i]])
                    }
                  })) {
                    return;
                  }
                  ++i;
                  if (i === end) {
                    return this["return"](lang.nil);
                  }
                }
              }
            });
            return SPECIAL_FORM;
          }
        ]
      })
    }
  });

  ListFunject.prototype.instance = lang.List.$instance;

  yakClass('Boolean', lang.Funject, {
    instance: {
      not: new Funject({
        call: [
          ['boolean'], function(x) {
            return yakBoolean(!x.value);
          }
        ],
        inverse: new Funject({
          call: [
            ['boolean', ['unknown']], function(x) {
              return new ListFunject([yakBoolean(!x.value)]);
            }
          ]
        })
      }),
      and: yakFunction(['boolean', 'boolean'], function(x, y) {
        return yakBoolean(x.value && y.value);
      }),
      or: yakFunction(['boolean', 'boolean'], function(x, y) {
        return yakBoolean(x.value || y.value);
      }),
      xor: yakFunction(['boolean', 'boolean'], function(x, y) {
        return yakBoolean(x.value !== y.value);
      })
    }
  });

  yakClass('Nil', lang.Funject);

  yakClass('Unknown', lang.Funject);

  yakClass('Error', lang.Funject, {
    exports: {
      "new": new Funject({
        call: [
          'interpreter', ['*'], function(interpreter, s) {
            return interpreter.createError('' + s);
          }
        ]
      })
    },
    instance: {
      initialize: new Funject({
        call: [
          'interpreter', ['*', ['string']], function(interpreter, e, s) {
            if (e.value != null) {
              throw new InterpreterError("" + e + " is immutable");
            }
            e.value = s.value;
            return e.stack = interpreter.stackTrace();
          }
        ]
      }),
      'inspect': yakFunction(['*'], function(e) {
        return new StringFunject("#<Error: " + e.value + "\n" + e.stack + ">");
      }),
      'to-string': yakFunction(['*'], function(e) {
        return new StringFunject(e.value + '\n' + e.stack);
      }),
      'to-error': yakFunction(['*'], function(e) {
        return e;
      }),
      'message': yakFunction(['*'], function(e) {
        return new StringFunject(e.value);
      })
    }
  });

  SymbolFunject = (function(_super) {
    __extends(SymbolFunject, _super);

    SymbolFunject.instances = {};

    SymbolFunject.prototype.instance = lang.Symbol.$instance;

    SymbolFunject.prototype.type = 'symbol';

    SymbolFunject.prototype.isSymbol = true;

    function SymbolFunject(value) {
      this.value = value;
    }

    SymbolFunject.prototype.toString = function() {
      return this.value;
    };

    SymbolFunject.prototype.toSource = function() {
      return "." + this.value;
    };

    SymbolFunject.prototype.call = [
      '.class', function() {
        return lang.Symbol;
      }
    ];

    return SymbolFunject;

  })(Funject);

  StringFunject = (function(_super) {
    __extends(StringFunject, _super);

    StringFunject.prototype.instance = lang.String.$instance;

    StringFunject.prototype.type = 'string';

    StringFunject.prototype.isString = true;

    function StringFunject(value) {
      this.value = value;
    }

    StringFunject.prototype.call = [
      'own', ['number'], function(s, n) {
        i = n.value < 0 ? s.value.length + n.value : n.value;
        if (i < 0 || i >= s.value.length) {
          return lang.nil;
        } else {
          return new StringFunject(s.value.charAt(i));
        }
      }, '.class', function() {
        return lang.String;
      }
    ];

    StringFunject.prototype.repeat = function(n) {
      if (!n.isInteger() || n.value < 0) {
        throw new InterpreterError("Cannot create " + (s.toSource()) + " * " + n);
      }
      return new StringFunject(Array(n.value + 1).join(this.value));
    };

    StringFunject.prototype.toString = function() {
      return this.value;
    };

    StringFunject.prototype.toSource = function() {
      return "'" + this.value.replace(/[\\]/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t') + "'";
    };

    return StringFunject;

  })(Funject);

  NumberFunject = (function(_super) {
    __extends(NumberFunject, _super);

    NumberFunject.prototype.instance = lang.Number.$instance;

    NumberFunject.prototype.type = 'number';

    NumberFunject.prototype.isNumber = true;

    NumberFunject.prototype.isInteger = function() {
      return this.value % 1 === 0;
    };

    NumberFunject.prototype.isFloat = function() {
      return this.value % 1 !== 0;
    };

    function NumberFunject(value) {
      this.value = value;
    }

    NumberFunject.prototype.toString = function() {
      return '' + this.value;
    };

    NumberFunject.prototype.toSource = function() {
      return '' + this.value;
    };

    NumberFunject.prototype.valueOf = function() {
      return this.value;
    };

    NumberFunject.prototype.call = [
      '.class', function() {
        return lang.Number;
      }
    ];

    return NumberFunject;

  })(Funject);

  BooleanFunject = (function(_super) {
    __extends(BooleanFunject, _super);

    BooleanFunject.prototype.instance = lang.Boolean.$instance;

    BooleanFunject.prototype.type = 'boolean';

    BooleanFunject.prototype.isBoolean = true;

    function BooleanFunject(value) {
      this.value = !!value;
    }

    BooleanFunject.prototype.toString = function() {
      return '' + this.value;
    };

    BooleanFunject.prototype.toSource = function() {
      return '' + this.value;
    };

    BooleanFunject.prototype.call = [
      '.class', function() {
        return lang.Boolean;
      }
    ];

    return BooleanFunject;

  })(Funject);

  lang.nil = new Funject({
    instance: lang.Nil.$instance,
    type: 'nil',
    isNil: true,
    toString: function() {
      return 'nil';
    },
    toSource: function() {
      return 'nil';
    }
  });

  lang.unknown = new Funject({
    instance: lang.Unknown.$instance,
    type: 'unknown',
    isUnknown: true,
    toString: function() {
      return 'unknown';
    },
    toSource: function() {
      return 'unknown';
    }
  });

  lang["true"] = new BooleanFunject(true);

  lang["false"] = new BooleanFunject(false);

  globalScope = new ((function(_super) {
    __extends(_Class, _super);

    _Class.prototype.name = '<global scope>';

    function _Class() {
      _Class.__super__.constructor.call(this, null, lang);
    }

    _Class.prototype.get = function(name) {
      try {
        return _Class.__super__.get.call(this, name);
      } catch (_error) {
        e = _error;
        if ((Object.prototype.hasOwnProperty.call(environment, name)) || (Object.prototype.hasOwnProperty.call(environment.__proto__, name))) {
          return Funject.bridge(environment[name]);
        } else if (name === 'require' && (typeof module !== "undefined" && module !== null)) {
          return Funject.bridge(require);
        } else {
          throw e;
        }
      }
    };

    return _Class;

  })(Scope));

  _ref2 = ['^', '*', '/', '%', '+', '-', '==', '!=', '<', '>', '<=', '>=', 'is', 'isnt'];
  for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
    operator = _ref2[_i];
    globalScope.set(operator, yakSymbol(operator));
  }

  globalScope.set('by', yakFunction(['symbol'], function(s) {
    return yakFunction(['*'], function(x) {
      return {
        lazy: {
          type: 'application',
          funject: {
            type: 'value',
            value: x
          },
          argument: {
            type: 'value',
            value: s
          }
        }
      };
    });
  }));

  globalScope.set('import', new Funject({
    call: [
      'interpreter', ['string'], function(interpreter, file) {
        var scope, tree;
        try {
          file = require('fs').readFileSync(file.value).toString();
        } catch (_error) {
          throw new InterpreterError("Cannot import " + file);
        }
        tree = parser.parse(file);
        interpreter.pop();
        scope = interpreter.scope;
        interpreter.push({
          type: 'native',
          value: function() {
            var exp;
            exp = this.scope.vars.exports;
            this.scope = scope;
            return this["return"](exp);
          }
        });
        interpreter.scope = new Scope(null, {
          exports: new Funject
        });
        interpreter.push(tree);
        return SPECIAL_FORM;
      }
    ]
  }));

  globalScope.set('error', new Funject({
    call: [
      'interpreter', ['*'], function(interpreter, message) {
        interpreter.pop();
        interpreter.pop();
        interpreter.callStack.pop();
        throw new InterpreterError('' + message);
        return SPECIAL_FORM;
      }
    ]
  }));

  globalScope.set('throw', new Funject({
    call: [
      'interpreter', ['*'], function(interpreter, error) {
        var call, exp;
        exp = interpreter.frame.expression;
        interpreter.pop();
        call = {
          type: 'application',
          file: exp != null ? exp.file : void 0,
          line: exp != null ? exp.line : void 0,
          character: exp != null ? exp.character : void 0,
          funject: {
            type: 'value',
            value: error
          },
          argument: {
            type: 'symbol',
            value: 'to-error'
          }
        };
        interpreter.push({
          type: 'native',
          value: function() {
            if (!this.args(call)) {
              return;
            }
            interpreter.pop();
            interpreter.pop();
            interpreter.callStack.pop();
            throw new UserError(this.first());
          }
        });
        return SPECIAL_FORM;
      }
    ]
  }));

  globalScope.set('print', new Funject({
    call: [
      ['*'], function(thing) {
        _exports.print('' + thing);
        return lang.nil;
      }
    ]
  }));

  globalScope.set('inspect', new Funject({
    call: [
      ['*'], function(thing) {
        _exports.print(thing.toSource(-1));
        return lang.nil;
      }
    ]
  }));

  itself = function(n) {
    return this["return"](lang[n.type]);
  };

  variable = function(n) {
    return this["return"](this.scope.get(n.value));
  };

  logical = function(n) {
    var left, right;
    if (!this.args(n.left)) {
      return;
    }
    left = this.first();
    if (!left.isBoolean) {
      throw new InterpreterError("Non-boolean applied to #" + n.type);
    }
    if ((n.type === 'and' ? !left.value : left.value)) {
      return this["return"](yakBoolean(n.type === 'or'));
    }
    if (!this.args(n.left, n.right)) {
      return;
    }
    right = this.second();
    if (!right.isBoolean) {
      throw new InterpreterError("#" + n.type + " applied to non-boolean");
    }
    return this["return"](yakBoolean(right.value));
  };

  proxy = function(f) {
    return function(n) {
      f.call(this, n);
      if (this.frame["arguments"].length) {
        return this["return"](this.first());
      } else {
        return this.pop();
      }
    };
  };

  Interpreter = (function() {
    function Interpreter() {}

    Interpreter.prototype.expressions = {
      number: function(n) {
        return this["return"](new NumberFunject(n.value));
      },
      symbol: function(n) {
        return this["return"](yakSymbol(n.value));
      },
      string: function(n) {
        return this["return"](new StringFunject(n.value));
      },
      boolean: function(n) {
        return this["return"](lang[n.value]);
      },
      nil: itself,
      unknown: itself,
      value: function(n) {
        return this["return"](n.value);
      },
      'pop scope': proxy(function(n) {
        return this.scope = this.scope.parent;
      }),
      'set scope': proxy(function(n) {
        return this.scope = n.scope;
      }),
      'pop call stack': proxy(function() {
        return this.callStack.pop();
      }),
      'pop catch stack': proxy(function() {
        return this.catchStack.pop();
      }),
      'ignore arguments': function() {
        return this.pop();
      },
      'reapply funject': function(n) {
        return n.funject.apply(this, n.own, n.argument, n["private"], n.instance);
      },
      "native": function(n) {
        return n.value.call(this, n);
      },
      sequence: function(n) {
        if (this.frame["arguments"].length === 0) {
          this.scope = new Scope(this.scope);
          this.scope.isProxy = n.isProxy;
          this.scope.name = '<sequence>';
          this.scope.line = n.line;
          this.scope.character = n.character;
        }
        if (!this.args.apply(this, n.expressions)) {
          return;
        }
        this.popScope();
        return this["return"](last(this.frame["arguments"]));
      },
      assignment: function(n) {
        var funject;
        switch (n.operator) {
          case 'inverse assignment':
            if (!this.args(n.left, n.right)) {
              return;
            }
            this.first().inverse = this.second();
            return this["return"](this.first());
          case 'inheritance assignment':
            if (!this.args(n.left, n.right)) {
              return;
            }
            this.first().parent = this.second();
            return this["return"](this.first());
        }
        if (n.left.type === 'identifier') {
          switch (n.operator) {
            case 'strict assignment':
              if (!this.args(n.right)) {
                return;
              }
              this.scope.set(n.left.value, this.first());
              return this["return"](this.first());
            case 'reset strict assignment':
              if (!this.args(n.right)) {
                return;
              }
              this.scope.reset(n.left.value, this.first());
              return this["return"](this.first());
            case 'lazy assignment':
              this.scope.set(n.left.value, {
                lazy: n.right,
                scope: this.scope
              });
              return this["return"](lang.nil);
            case 'reset lazy assignment':
              this.scope.reset(n.left.value, {
                lazy: n.right,
                scope: this.scope
              });
              return this["return"](lang.nil);
          }
        }
        if (n.left.type === 'application') {
          if (!this.args(n.left.funject)) {
            return;
          }
          funject = this.first();
          if (funject.isInstance && !_exports.allowClassRedefinition) {
            throw new InterpreterError('Cannot modify class definition');
          }
          if (n.operator !== 'lazy assignment' && this.frame["arguments"].length === 1) {
            this.push(n.right);
            return;
          }
          (funject.patterns != null ? funject.patterns : funject.patterns = []).unshift((n.operator === 'lazy assignment' ? {
            pattern: n.left.argument,
            expression: n.right,
            scope: this.scope
          } : {
            pattern: n.left.argument,
            value: this.second(),
            scope: this.scope
          }));
          return this["return"]((n.operator === 'lazy assignment' ? lang.nil : this.second()));
        }
        throw new InterpreterError("Unimplemented: " + n.operator);
      },
      identifier: variable,
      'formal parameter': variable,
      list: function(n) {
        if (!this.args.apply(this, n.values)) {
          return;
        }
        return this["return"](new ListFunject(this.frame["arguments"]));
      },
      funject: function(n) {
        var f;
        f = new Funject;
        f.expression = n;
        f.patterns = (function() {
          var _j, _len1, _ref3, _results;
          _ref3 = n.patterns;
          _results = [];
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            p = _ref3[_j];
            _results.push({
              pattern: p.pattern,
              expression: p.value,
              scope: this.scope
            });
          }
          return _results;
        }).call(this);
        return this["return"](f);
      },
      "if": function(n) {
        var condition, _ref3;
        if (!this.args(n.condition, {
          type: 'application',
          funject: {
            type: 'value',
            value: this.first()
          },
          argument: {
            type: 'symbol',
            value: 'to-boolean'
          }
        })) {
          return;
        }
        condition = this.second();
        if (condition !== lang["true"] && condition !== lang["false"]) {
          throw new InterpreterError("Cannot convert " + (this.first()) + " to boolean");
        }
        if (!this.args(0, 0, (condition === lang["true"] ? n.trueBody : (_ref3 = n.falseBody) != null ? _ref3 : {
          type: 'nil'
        }))) {
          return;
        }
        return this["return"](this.third());
      },
      "try": function(n) {
        this.pop();
        if (n["finally"]) {
          this.push(n["finally"]);
          this.push({
            type: 'ignore arguments'
          });
        }
        this.catchStack.push({
          index: this.stack.length,
          callIndex: this.callStack.length,
          expression: n,
          scope: this.scope
        });
        this.push({
          type: 'pop catch stack'
        });
        return this.push(n.body);
      },
      module: function(n) {
        var exports;
        p = n.parent != null;
        if (p && !this.args(n.parent)) {
          return;
        }
        argc = p ? 1 : 0;
        if (this.frame["arguments"].length === argc) {
          this.frame["super"] = p ? this.first() : lang.Funject;
          this.push({
            type: 'pop scope'
          });
          this.scope = this.frame.scope = new Scope(this.scope, {
            exports: new Funject({
              parent: this.frame["super"]
            }),
            "super": this.frame["super"]
          }, true);
          if (p) {
            this.args(n.parent, n.body);
          } else {
            this.args(n.body);
          }
          return;
        }
        exports = this.frame.scope.vars.exports;
        exports.parent = this.frame["super"];
        return this["return"](exports);
      },
      "class": function(n) {
        var exports, externalInstance, instance, prototype;
        if ((e = this.stack[this.stack.length - 2].expression) && e.type === 'assignment' && e.left.type === 'identifier') {
          this.frame.name = e.left.value;
        } else {
          this.frame.name = '<class>';
        }
        p = n.parent != null;
        if (p && !this.args(n.parent)) {
          return;
        }
        argc = p ? 1 : 0;
        if (this.frame["arguments"].length === argc) {
          this.frame["super"] = p ? this.first() : lang.Funject;
          if (!this.frame["super"].isClass) {
            throw new InterpreterError("Cannot inherit from " + this.frame["super"]);
          }
          this.push({
            type: 'pop scope'
          });
          this.scope = this.frame.scope = new Scope(this.scope, {
            exports: new ClassFunject({
              parent: this.frame["super"],
              name: this.frame.name,
              expression: n
            }),
            "super": this.frame["super"],
            instance: new Funject({
              parent: this.frame["super"].$instance
            })
          }, true);
          n.body.isProxy = true;
          if (p) {
            this.args(0, n.body);
          } else {
            this.args(n.body);
          }
          return;
        }
        exports = this.frame.scope.vars.exports;
        exports.parent = this.frame["super"];
        exports.$super = this.frame["super"];
        exports.$subclasses = new ListFunject([]);
        this.frame["super"].$subclasses.value.push(exports);
        instance = exports.$instance = this.frame.scope.vars.instance;
        instance.isInstance = true;
        instance.name = "" + this.frame.name + ".instance";
        instance.expression = n;
        instance.parent = this.frame["super"].$instance;
        prototype = yakObject(null, {
          "class": exports
        });
        externalInstance = new Funject({
          call: [
            'interpreter', 'symbol', function(interpreter, s) {
              var exp;
              exp = interpreter.frame.expression;
              interpreter.pop();
              interpreter.push({
                type: 'native',
                value: function() {
                  var method;
                  if (!this.args({
                    type: 'application',
                    funject: {
                      type: 'value',
                      value: instance
                    },
                    argument: {
                      type: 'value',
                      value: s
                    }
                  })) {
                    return;
                  }
                  method = this.first();
                  if (method.name == null) {
                    method.name = 'instance.' + s.value;
                  }
                  return this["return"](new Funject({
                    call: [
                      'interpreter', ['|', ['*'], ['*', '*']], function(interpreter, x, y) {
                        interpreter.pop();
                        interpreter.pop();
                        interpreter.callStack.pop();
                        interpreter.push({
                          type: 'application',
                          file: exp != null ? exp.file : void 0,
                          line: exp != null ? exp.line : void 0,
                          character: exp != null ? exp.character : void 0,
                          funject: {
                            type: 'value',
                            value: method
                          },
                          argument: {
                            type: 'value',
                            value: new ListFunject((y ? [x, y] : [x]))
                          },
                          "private": x["private"] != null ? x["private"] : x["private"] = new Funject
                        });
                        return SPECIAL_FORM;
                      }
                    ]
                  }));
                }
              });
              return SPECIAL_FORM;
            }
          ]
        });
        (exports.call != null ? exports.call : exports.call = []).unshift('.instance', function() {
          return externalInstance;
        }, 'interpreter', '.new', function(interpreter) {
          var exp;
          exp = interpreter.frame.expression;
          interpreter.pop();
          interpreter.pop();
          interpreter.callStack.pop();
          interpreter.push({
            type: 'native',
            value: function() {
              var hasArgs, initialize, initializeCall, result;
              initializeCall = {
                type: 'application',
                file: exp != null ? exp.file : void 0,
                line: exp != null ? exp.line : void 0,
                character: exp != null ? exp.character : void 0,
                instance: false,
                funject: {
                  type: 'value',
                  value: instance
                },
                argument: {
                  type: 'symbol',
                  value: 'initialize'
                }
              };
              if (!this.args(initializeCall)) {
                return;
              }
              initialize = this.first();
              if (initialize.name == null) {
                initialize.name = 'instance.initialize';
              }
              hasArgs = initialize.methodHasArgs();
              result = new Funject({
                parent: prototype,
                instance: instance
              });
              if (hasArgs) {
                return this["return"](new Funject({
                  call: [
                    'interpreter', '*', function(interpreter, arg) {
                      interpreter.pop();
                      interpreter.push({
                        type: 'value',
                        value: result
                      });
                      interpreter.push({
                        type: 'application',
                        file: exp != null ? exp.file : void 0,
                        line: exp != null ? exp.line : void 0,
                        character: exp != null ? exp.character : void 0,
                        "private": result["private"] != null ? result["private"] : result["private"] = new Funject,
                        funject: {
                          type: 'value',
                          value: initialize
                        },
                        argument: {
                          type: 'value',
                          value: new ListFunject([result, arg])
                        }
                      });
                      return SPECIAL_FORM;
                    }
                  ]
                }));
              } else {
                this.pop();
                this.push({
                  type: 'value',
                  value: result
                });
                return this.push({
                  type: 'application',
                  file: exp != null ? exp.file : void 0,
                  line: exp != null ? exp.line : void 0,
                  character: exp != null ? exp.character : void 0,
                  "private": result["private"] != null ? result["private"] : result["private"] = new Funject,
                  funject: {
                    type: 'value',
                    value: initialize
                  },
                  argument: {
                    type: 'value',
                    value: new ListFunject([result])
                  }
                });
              }
            }
          });
          return SPECIAL_FORM;
        });
        return this["return"](exports);
      },
      application: function(n) {
        var argument, funject, _ref3;
        if (!this.args(n.funject, n.argument)) {
          return;
        }
        if (this.frame["arguments"].length > 2) {
          return this["return"](this.frame["arguments"][2]);
        }
        funject = this.first();
        argument = this.second();
        this.stack.splice(this.stack.length - 1, 0, {
          expression: {
            type: 'pop call stack'
          },
          "arguments": []
        });
        this.callStack.push({
          expression: n,
          name: funject.name
        });
        return funject.apply(this, (_ref3 = n.own) != null ? _ref3 : funject, argument, n["private"], n.instance);
      },
      or: logical,
      and: logical
    };

    Interpreter.prototype.load = function(n) {
      this.scope = globalScope;
      this.stack = [
        {
          "arguments": []
        }
      ];
      this.callStack = [];
      this.catchStack = [];
      n.isProxy = true;
      this.push(n);
      return this;
    };

    Interpreter.prototype.evaluate = function(n) {
      this.load(n);
      while (this.stack.length > 1) {
        this.step();
      }
      return last(this.stack[0]["arguments"]);
    };

    Interpreter.prototype.step = function(n) {
      var entry, error, errorFunject, type, _ref3;
      if (this.stack.length === 1) {
        return true;
      }
      this.frame = last(this.stack);
      try {
        this.expression();
      } catch (_error) {
        error = _error;
        if (error instanceof InterpreterError || error instanceof UserError) {
          errorFunject = (_ref3 = error.error) != null ? _ref3 : this.createError(error.message);
          while (this.catchStack.length) {
            entry = this.catchStack.pop();
            try {
              type = entry.scope.get(entry.expression["class"].value);
            } catch (_error) {}
            if (type && errorFunject.isKindOf(type)) {
              this.stack = this.stack.slice(0, +(entry.index - 1) + 1 || 9e9);
              this.callStack = this.callStack.slice(0, +(entry.callIndex - 1) + 1 || 9e9);
              if (entry.expression.name) {
                this.scope = new Scope(entry.scope);
                this.scope.set(entry.expression.name.value, errorFunject);
              } else {
                this.scope = entry.scope;
              }
              this.push(entry.expression["catch"]);
              return;
            }
          }
          throw new RuntimeError(errorFunject.value, errorFunject.value + '\n' + errorFunject.stack);
        } else {
          if (typeof require !== "undefined" && require !== null) {
            console.log(require('util').inspect(this.stack, {
              depth: 5
            }));
          }
          throw error;
        }
      }
      return false;
    };

    Interpreter.prototype.stackTrace = function() {
      var calls, n, name, stack, _j, _len1, _ref3;
      stack = '';
      calls = this.callStack.slice(0);
      calls.push({
        expression: this.frame.expression
      });
      name = null;
      for (_j = 0, _len1 = calls.length; _j < _len1; _j++) {
        _ref3 = calls[_j], e = _ref3.expression, n = _ref3.name;
        if (name) {
          if (e.file) {
            stack = ("\n at " + name + " (" + e.file + ":" + e.line + ":" + e.character + ")") + stack;
          } else {
            stack = ("\n at " + name) + stack;
          }
        } else {
          if (e.file) {
            stack = ("\n at " + e.file + ":" + e.line + ":" + e.character) + stack;
          } else {
            stack = "\n at <anonymous>" + stack;
          }
        }
        name = n;
      }
      return stack.substr(1);
    };

    Interpreter.prototype.createError = function(message) {
      var error;
      error = lang.Error.create();
      error.value = message;
      error.stack = this.stackTrace();
      return error;
    };

    Interpreter.prototype.value = function() {
      return last(this.stack[0]["arguments"]);
    };

    Interpreter.prototype.arg = function(i, value) {
      var a, scope;
      if (i > this.frame["arguments"].length) {
        throw new TypeError("Invalid arg(..) offset " + i);
      }
      if (i === this.frame["arguments"].length) {
        this.push(value);
        return false;
      }
      if ((a = this.frame["arguments"][i]).lazy) {
        this.frame["arguments"].pop();
        scope = this.scope;
        this.push({
          type: 'set scope',
          scope: scope
        });
        this.scope = a.scope;
        this.push(a.lazy);
        return false;
      }
      return true;
    };

    Interpreter.prototype.args = function() {
      var args, length;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      length = this.frame["arguments"].length;
      if (length && this.frame["arguments"][length - 1].lazy) {
        this.arg(length - 1, args[length - 1]);
        return false;
      }
      if (length < args.length) {
        this.push(args[length]);
        return false;
      }
      return true;
    };

    Interpreter.prototype.expression = function() {
      var n;
      n = this.frame.expression;
      if (this.expressions[n.type] == null) {
        throw new Error("Invalid expression type " + n.type);
      }
      return this.expressions[n.type].call(this, n);
    };

    Interpreter.prototype["return"] = function(value) {
      this.stack.pop();
      return last(this.stack)["arguments"].push(value);
    };

    Interpreter.prototype.push = function(n) {
      return this.stack.push({
        expression: n,
        "arguments": []
      });
    };

    Interpreter.prototype.pop = function() {
      return this.stack.pop();
    };

    Interpreter.prototype.popScope = function() {
      return this.scope = this.scope.parent;
    };

    Interpreter.prototype.first = function(n) {
      return this.frame["arguments"][0];
    };

    Interpreter.prototype.second = function(n) {
      return this.frame["arguments"][1];
    };

    Interpreter.prototype.third = function(n) {
      return this.frame["arguments"][2];
    };

    return Interpreter;

  })();

  evaluateSynchronous = function(source, filename, firstLine) {
    return new Interpreter().evaluate(parser.parse(source, filename, firstLine));
  };

  MAX_ITERATIONS = 1000;

  evaluate = function(source, filename, firstLine, callback) {
    var callbacks, dataCallbacks, errorCallbacks, interpreter, result, step, timeout;
    if (filename == null) {
      filename = '<anonymous>';
    }
    if (firstLine == null) {
      firstLine = 1;
    }
    if (callback == null) {
      callback = null;
    }
    callbacks = [];
    dataCallbacks = [];
    errorCallbacks = [];
    result = function(error, data) {
      var c, _j, _k, _l, _len1, _len2, _len3, _results;
      for (_j = 0, _len1 = callbacks.length; _j < _len1; _j++) {
        c = callbacks[_j];
        c(error, data);
      }
      if (data) {
        for (_k = 0, _len2 = dataCallbacks.length; _k < _len2; _k++) {
          c = dataCallbacks[_k];
          c(data);
        }
      }
      if (error) {
        _results = [];
        for (_l = 0, _len3 = errorCallbacks.length; _l < _len3; _l++) {
          c = errorCallbacks[_l];
          _results.push(c(error));
        }
        return _results;
      }
    };
    if (arguments.length === 2) {
      callback = filename;
      filename = '<anonymous>';
    }
    if (callback) {
      callbacks.push(callback);
    }
    try {
      interpreter = new Interpreter().load(parser.parse(source, filename, firstLine));
      timeout = setTimeout(step = function() {
        var iterations;
        iterations = 0;
        try {
          while (true) {
            if (interpreter.step()) {
              result(null, interpreter.value());
              return;
            } else if (++iterations >= MAX_ITERATIONS) {
              timeout = setTimeout(step);
              return;
            }
          }
        } catch (_error) {
          e = _error;
          if (e instanceof RuntimeError) {
            return result(e, null);
          } else {
            throw e;
          }
        }
      });
    } catch (_error) {
      e = _error;
      if (e instanceof SyntaxError) {
        setTimeout(function() {
          return result(e, null);
        });
      } else {
        throw e;
      }
    }
    return {
      abort: function() {
        clearTimeout(timeout);
        return this;
      },
      then: function(callback) {
        callbacks.push(callback);
        return this;
      },
      done: function(callback) {
        dataCallbacks.push(callback);
        return this;
      },
      fail: function(callback) {
        errorCallbacks.push(callback);
        return this;
      }
    };
  };

  repl = function() {
    var FIXED_LINE_LENGTH, firstLine, read, readline, replLine, request, rl, setPrompt, sigints;
    readline = require('readline');
    rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
      completer: function(line) {
        var s;
        if (/^\s*$/.test(line)) {
          if (s = /(^|\n)([ \t]+).*\n$/.exec(read)) {
            if (line.length >= s[2].length) {
              return [[line + '    '], line];
            } else {
              return [[s[2]], line];
            }
          } else {
            return [[line + '    '], line];
          }
        } else {
          return [[], line];
        }
      }
    });
    FIXED_LINE_LENGTH = 4;
    replLine = 1;
    setPrompt = function(postfix) {
      var s;
      if (postfix == null) {
        postfix = '>';
      }
      s = '' + replLine;
      while (s.length < FIXED_LINE_LENGTH) {
        s = '0' + s;
      }
      return rl.setPrompt(s + postfix + ' ');
    };
    setPrompt('>');
    rl.prompt();
    read = '';
    firstLine = 1;
    sigints = 0;
    request = null;
    rl.on('line', function(line) {
      ++replLine;
      sigints = 0;
      if (line === '' && read === '') {
        setPrompt('>');
        rl.prompt();
        firstLine = replLine;
        return;
      }
      read += line + '\n';
      if (!/^[\t ]|(^|[(\[])(class|module|try|catch|finally|if|else)\b|\[[^\]]*$|\([^)]*$|\{[^\}]*$/.test(line)) {
        return request = evaluate(read, 'input', firstLine, function(e, d) {
          if (e) {
            if (e.trace) {
              console.log(e.trace);
            } else if (e.message) {
              console.log(e.message);
            }
          } else if (d) {
            console.log(d.toSource(3));
          }
          request = null;
          read = '';
          firstLine = replLine;
          setPrompt('>');
          return rl.prompt();
        });
      } else {
        setPrompt(':');
        return rl.prompt();
      }
    });
    rl.on('SIGINT', function() {
      if (request != null) {
        request.abort();
        read = '';
      } else {
        rl._refreshLine();
        if (rl.line === '' && read === '') {
          if (sigints) {
            rl.close();
          } else {
            sigints = 1;
            rl.clearLine();
            console.log('(^C again to quit)');
          }
        } else {
          sigints = 0;
          rl.clearLine();
          read = '';
        }
      }
      ++replLine;
      firstLine = replLine;
      setPrompt('>');
      return rl.prompt();
    });
    return rl.on('close', function() {
      console.log('');
      return process.exit(0);
    });
  };

  if (typeof module !== "undefined" && module !== null) {
    fs = require('fs');
    path = require('path');
    parser = require('./parser.coffee');
    _exports = exports;
    _exports.repl = repl;
  } else {
    parser = Yak.parser;
    (this.Yak = evaluateSynchronous).parser = parser;
    Yak.interpreter = _exports = {};
  }

  _exports.allowClassRedefinition = false;

  _exports["eval"] = evaluate;

  _exports.evalSync = evaluateSynchronous;

  _exports.print = function(string) {
    return console.log(string);
  };

  _exports.evalFile = function(filename, cb) {
    return fs.readFile(filename, function(err, data) {
      if (err != null) {
        cb(err);
      }
      return evaluate(data.toString(), filename, 1, cb);
    });
  };

  _exports.evalFileSync = function(filename) {
    return evaluateSynchronous(fs.readFileSync(filename).toString(), filename, 1);
  };

  if ((typeof module !== "undefined" && module !== null) && !module.parent) {
    expressions = [];
    i = 2;
    expressionNumber = 1;
    argc = process.argv.length;
    interactive = false;
    while (i < argc) {
      switch (arg = process.argv[i++]) {
        case '-h':
          console.error('Usage: coffee interpreter.coffee [ <filename> | -e <expression> | -i | -h ]');
          return;
        case '-i':
          interactive = true;
          break;
        case '--allow-class-redefinition':
          _exports.allowClassRedefinition = true;
          break;
        case '-e':
          expressions.push({
            file: "expression" + (expressionNumber++),
            source: process.argv[i++]
          });
          break;
        default:
          expressions.push({
            file: path.resolve(arg),
            source: '' + fs.readFileSync(arg)
          });
      }
    }
    for (_j = 0, _len1 = expressions.length; _j < _len1; _j++) {
      expression = expressions[_j];
      try {
        evaluateSynchronous(expression.source, expression.file);
      } catch (_error) {
        e = _error;
        if (e instanceof SyntaxError) {
          console.error(e.message);
        } else {
          throw e;
        }
      }
    }
    if (interactive || expressions.length === 0) {
      repl();
    }
  }

  interpreted = [];

  interpret = function(str) {
    interpreted.push(str);
    console.log($('body')[0]);
    console.debug(str);
    return Yak.interpreter.evalSync(str);
  };

  MutationObserver = window.MutationObserver || window.WebKitMutationObserver;

  onInserted = function(callback) {
    return (new MutationObserver(function(muts) {
      return callback(muts.filter(function(mut) {
        return true;
      }).map(function(mut) {
        return Array.prototype.slice.call(mut.addedNodes, 0);
      }).reduce(function(a, b) {
        return a.concat(b);
      }));
    })).observe(document, {
      childList: true,
      subtree: true
    });
  };

  onInserted(function(elems) {
    return elems.filter(function(elem) {
      return $(elem).is("script[type=\"text/yak\"]");
    }).map(function(elem) {
      if ($(elem).is("[src]")) {
        if ($(elem).attr("src").match(/^http:\/\//)) {
          $.get("http://www.corsproxy.com/" + $(elem).attr("src").match(/^http:\/\/(.+)/)[1], function(data) {});
          console.debug("local src interpret:");
          return interpret(data);
        } else {
          return $.get($(elem).attr("src"), function(data) {
            console.debug("local src interpret:");
            return interpret(data);
          });
        }
      } else {
        console.debug("inline interpret:");
        return interpret($(elem).text().replace(/^[ \t]*\n/, '').replace(/[\n\ \t]*$/, ''));
      }
    });
  });

}).call(this);
