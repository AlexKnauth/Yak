// Generated by CoffeeScript 1.6.3
(function() {
  var last, parseError, printTokens,
    __slice = [].slice;

  parseError = function(token, message) {
    throw new SyntaxError("" + message + " at :" + token.line + ":" + token.character);
  };

  last = function(thing) {
    return thing[thing.length - 1];
  };

  this.tokenizer = (function() {
    var isDigit, isIdentifier, isSpace, symbol;
    symbol = {
      '(': 'group start',
      ')': 'group end',
      '{': 'funject start',
      '}': 'funject end',
      '[': 'list start',
      ',': 'list delimiter',
      ']': 'list end',
      ':': 'pattern match',
      '=': 'strict assignment',
      ':=': 'lazy assignment',
      '|=': 'reset strict assignment',
      '|:=': 'reset lazy assignment',
      '<-': 'inverse assignment',
      '<<': 'inheritance'
    };
    isSpace = function(c) {
      return c === ' ' || c === '\t';
    };
    isDigit = function(c) {
      return -1 !== '0123456789'.indexOf(c);
    };
    isIdentifier = function(c) {
      return -1 !== '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-=?!'.indexOf(c);
    };
    return function(s) {
      var advance, character, here, i, indent, lastNewline, length, line, next, prev, syntaxError, token, tokens;
      token = function(type, value) {
        if (value == null) {
          value = '';
        }
        return {
          type: type,
          value: value,
          line: line,
          character: character
        };
      };
      syntaxError = function(message) {
        throw new SyntaxError("" + message + " at :" + line + ":" + character);
      };
      i = 0;
      character = 0;
      lastNewline = 0;
      line = 1;
      length = s.length;
      indent = [''];
      tokens = [];
      advance = function() {
        var c, delimiter, digit, l, now, prev, q, space, start, type, value;
        if (tokens.length) {
          return tokens.shift();
        }
        c = s[i];
        while (isSpace(c)) {
          ++i;
          c = s[i];
        }
        if (i >= length) {
          if (indent.length > 1) {
            indent.pop();
            return token('outdent');
          }
          return token('end');
        }
        character = 1 + i - lastNewline;
        if ((q = s.substr(i, 3)) === '|:=' || (q = s.substr(i, 2)) === ':=' || q === '|=' || q === '<-' || q === '<<') {
          i += q.length;
          return token(symbol[q], q);
        }
        switch (c) {
          case '\n':
            while (true) {
              while (c === '\n') {
                ++i;
                ++line;
                lastNewline = i;
                character = 1 + i - lastNewline;
                c = s[i];
              }
              space = '';
              while (true) {
                c = s[i];
                if (!isSpace(c)) {
                  break;
                }
                space += c;
                ++i;
              }
              if (c !== '\n') {
                break;
              }
            }
            l = last(indent);
            now = space.length;
            prev = l.length;
            switch (false) {
              case now !== prev:
                if (space !== l) {
                  syntaxError('Inconsistent indentation');
                }
                return token('newline');
              case !(now < prev):
                while (now < prev) {
                  tokens.push(token('outdent'));
                  indent.pop();
                  l = last(indent);
                  prev = l.length;
                }
                if (space !== l) {
                  syntaxError('Inconsistent indentation');
                }
                return tokens.shift();
              case !(now > prev):
                if (l !== space.substr(0, prev)) {
                  syntaxError('Inconsistent indentation');
                }
                indent.push(space);
                return token('indent');
            }
            break;
          case '{':
          case '}':
          case '[':
          case ']':
          case ':':
          case '=':
          case ',':
          case '(':
          case ')':
            ++i;
            return token(symbol[c], c);
        }
        if (c === '-') {
          q = s[i + 1];
          if (q === '.' || isDigit(q)) {
            digit = true;
          }
        }
        if (digit || c === '.' || isDigit(c)) {
          value = '';
          start = i;
          if (c === '-') {
            value += c;
            ++i;
            c = s[i];
          }
          if (isDigit(c)) {
            while (true) {
              value += c;
              ++i;
              c = s[i];
              if (!isDigit(c)) {
                break;
              }
            }
          }
          if (c === '.') {
            value += c;
            ++i;
            c = s[i];
            if (!isDigit(c)) {
              if (value === '.') {
                return token('dot application', '.');
              }
              character = 1 + i - lastNewline;
              syntaxError('Expected digit');
            }
            while (true) {
              value += c;
              ++i;
              c = s[i];
              if (!isDigit(c)) {
                break;
              }
            }
          }
          if (c === 'e' || c === 'E') {
            value += c;
            ++i;
            c = s[i];
            if (c === '+' || c === '-') {
              value += c;
              ++i;
              c = s[i];
            }
            if (!isDigit(c)) {
              character = 1 + i - lastNewline;
              syntaxError('Expected digit');
            }
            while (true) {
              value += c;
              ++i;
              c = s[i];
              if (!isDigit(c)) {
                break;
              }
            }
          }
          if (isIdentifier(c)) {
            i = start;
            c = s[i];
          } else {
            return token('number', +value);
          }
        }
        if (c === '@' || isIdentifier(c)) {
          type = c === '@' ? 'formal parameter' : 'identifier';
          value = '';
          while (true) {
            value += c;
            ++i;
            c = s[i];
            if (!isIdentifier(c)) {
              break;
            }
          }
          if (value === 'true' || value === 'false') {
            return token('boolean', value === 'true');
          }
          if (value === 'nil' || value === 'dot' || value === 'unknown') {
            return token(value, value);
          }
          return token(type, value);
        }
        if (c === '"' || c === "'") {
          delimiter = c;
          value = '';
          ++i;
          c = s[i];
          while (true) {
            if (!c) {
              syntaxError('Unterminated string');
            }
            if (c === delimiter) {
              break;
            }
            value += c;
            ++i;
            c = s[i];
          }
          ++i;
          return token('string', value);
        }
        if (c === '.') {
          ++i;
          return token('dot application');
        }
        return syntaxError("Unexpected " + c);
      };
      here = advance();
      next = advance();
      prev = null;
      return {
        here: function() {
          return here;
        },
        next: function() {
          return next;
        },
        advance: function() {
          prev = here;
          here = next;
          next = advance();
          return prev;
        },
        match: function() {
          var types;
          types = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          if (-1 !== types.indexOf(here.type)) {
            return this.advance();
          }
          if (prev && prev.type === 'outdent' && -1 !== types.indexOf('newline')) {
            return {
              type: 'newline',
              value: '',
              line: prev.line,
              character: prev.character
            };
          }
          return null;
        },
        accept: function() {
          var values;
          values = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          if (-1 !== values.indexOf(here.value)) {
            return this.advance();
          }
          return null;
        },
        require: function() {
          var types;
          types = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return this.match.apply(this, types) || parseError(here, "Expected " + (types.join(" or ")));
        },
        requireValue: function() {
          var values;
          values = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return this.accept.apply(this, values) || parseError(here, "Expected '" + (values.join("', '")) + "'");
        }
      };
    };
  })();

  this.parse = (function() {
    var Symbol, expression, parse, statement, statements, symbols, value;
    symbols = {};
    Symbol = (function() {
      function Symbol() {}

      Symbol.prototype["null"] = function() {
        return parseError("Unexpected operator");
      };

      Symbol.prototype.left = function() {
        return parseError("Unexpected value");
      };

      return Symbol;

    })();
    parse = function(s) {
      var result, tokens;
      tokens = tokenizer(s);
      result = statements(tokens);
      tokens.require('end');
      return result;
    };
    statements = function(tokens) {
      var result, s;
      result = [];
      while (true) {
        s = statement(tokens);
        if (!s) {
          break;
        }
        result.push(s);
        if (!tokens.match('newline')) {
          break;
        }
      }
      return result;
    };
    statement = function(tokens) {
      var assignment, e;
      e = expression(tokens, true);
      if (!e) {
        return;
      }
      if (assignment = tokens.match('strict assignment', 'lazy assignment', 'reset strict assignment', 'reset lazy assignment', 'inverse assignment', 'inheritance')) {
        if (e.type !== 'identifier' && e.type !== 'application') {
          parseError(assignment, 'Invalid left-hand side of assignment');
        }
        e = {
          type: assignment.type,
          line: assignment.line,
          character: assignment.character,
          left: e,
          right: expression(tokens)
        };
      }
      return e;
    };
    expression = function(tokens, optional) {
      var e, name, result, t;
      if (t = tokens.match('indent')) {
        result = statements(tokens);
        tokens.require('outdent');
        return {
          line: t.line,
          character: t.character,
          type: 'sequence',
          statements: result
        };
      }
      e = value(tokens);
      if (!e) {
        if (optional) {
          return null;
        } else {
          parseError(tokens.here(), "Expected expression");
        }
      }
      while (true) {
        if (t = tokens.match('dot application')) {
          name = tokens.require('identifier');
          e = {
            type: 'application',
            line: t.line,
            character: t.character,
            funject: e,
            argument: {
              type: 'list',
              line: t.line,
              character: t.character,
              values: [
                {
                  type: 'dot',
                  line: t.line,
                  character: t.character
                }, name
              ]
            }
          };
          continue;
        }
        if (-1 !== ['identifier', 'formal parameter', 'string', 'number', 'boolean', 'nil', 'dot', 'unknown', 'funject start', 'group start', 'list start'].indexOf(tokens.here().type)) {
          t = tokens.here();
          e = {
            type: 'application',
            line: t.line,
            character: t.character,
            funject: e,
            argument: value(tokens)
          };
          continue;
        }
        break;
      }
      return e;
    };
    value = function(tokens) {
      var e, pattern, patterns, result, t, values;
      if (tokens.match('group start')) {
        e = expression(tokens);
        tokens.require('group end');
        return e;
      }
      if (t = tokens.match('list start')) {
        values = [];
        if (!tokens.match('list end')) {
          while (true) {
            values.push(expression(tokens));
            if (tokens.match('list end')) {
              break;
            }
            tokens.require('list delimiter');
          }
        }
        return {
          line: t.line,
          character: t.character,
          type: 'list',
          values: values
        };
      }
      if (t = tokens.match('funject start')) {
        patterns = [];
        if (!tokens.match('funject end')) {
          if (tokens.match('indent')) {
            while (true) {
              pattern = expression(tokens);
              tokens.require('pattern match');
              result = expression(tokens);
              patterns.push({
                pattern: pattern,
                value: result
              });
              if (tokens.match('outdent')) {
                break;
              }
              tokens.require('newline');
            }
            tokens.require('funject end');
          } else {
            pattern = expression(tokens);
            tokens.require('pattern match');
            result = expression(tokens);
            patterns.push({
              pattern: pattern,
              result: result
            });
            tokens.require('funject end');
          }
        }
        return {
          line: t.line,
          character: t.character,
          type: 'funject',
          patterns: patterns
        };
      }
      if (t = tokens.match('identifier', 'formal parameter', 'string', 'number', 'boolean', 'nil', 'dot', 'unknown')) {
        return t;
      }
    };
    return parse;
  })();

  printTokens = function(s) {
    var indent, t, tokens, _results;
    tokens = tokenizer(s);
    indent = '';
    _results = [];
    while (true) {
      t = tokens.advance();
      if (t.type === 'end') {
        break;
      }
      switch (t.type) {
        case 'indent':
          console.log("" + indent + "{");
          _results.push(indent += '    ');
          break;
        case 'outdent':
          indent = indent.substr(4);
          _results.push(console.log("" + indent + "}"));
          break;
        case 'newline':
          _results.push(console.log("" + indent + ";"));
          break;
        default:
          _results.push(console.log("" + indent + "(:" + t.line + ":" + t.character + ") <" + t.type + "> " + t.value));
      }
    }
    return _results;
  };

  if (process) {
    console.log(JSON.stringify(parse(require('fs').readFileSync(process.argv[2]).toString()), void 0, 2));
  }

}).call(this);
