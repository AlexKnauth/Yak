// Generated by CoffeeScript 1.3.3
var also, append, apply, boolean_to_string, caaddddddddddr, caadddddddddr, caaddddddddr, caadddddddr, caaddddddr, caadddddr, caaddddr, caadddr, caaddr, caadr, caar, caddddddddddr, cadddddddddr, caddddddddr, cadddddddr, caddddddr, cadddddr, caddddr, cadddr, caddr, cadr, compose, count, display, error, given, given_seq, impossibility, is_boolean, is_empty, is_eq, is_equal, is_impossible, is_number, is_possible, is_string, is_symbol, least_acceptable_indent, matches, newline, number_to_string, possibility, raise, repeat, shallow_flatten, string_append, string_length, string_replace, string_to_number, substring, symbol_to_string, _racket_division_symbol, _racket_minus_symbol, _racket_mult_symbol, _racket_plus_symbol,
  __slice = [].slice;

string_to_number = Number;

number_to_string = String;

boolean_to_string = String;

symbol_to_string = function(sym) {
  return sym.toString();
};

is_equal = function(a, b) {
  return a === b;
};

is_eq = is_equal;

apply = function(f, args) {
  return f.apply({}, args);
};

display = newline = console.log;

raise = function(x) {
  throw x;
};

error = function(x) {
  throw x;
};

is_symbol = function(x) {
  return x.isSymbol === true;
};

is_string = function(x) {
  return x.constructor === String;
};

is_boolean = function(x) {
  return x.constructor === Boolean;
};

is_number = function(x) {
  return x.constructor === Number;
};

_racket_plus_symbol = function(a, b) {
  return a + b;
};

_racket_minus_symbol = function(a, b) {
  return a - b;
};

_racket_mult_symbol = function(a, b) {
  return a * b;
};

_racket_division_symbol = function(a, b) {
  return a / b;
};

matches = function(a, b) {
  return b.indexOf(a) !== -1;
};

string_length = function(str) {
  return str.length;
};

string_append = function() {
  return Array.prototype.reduce.call(arguments, function(a, b) {
    return a + b;
  });
};

string_replace = function(str, a, b) {
  return str.replace(a, b);
};

substring = function(str, start, end) {
  return str.slice(start, end);
};

count = function(f, xs) {
  return xs.filter(f).length;
};

is_empty = function(xs) {
  return xs.length === 0;
};

append = function() {
  return Array.prototype.reduce.call(arguments, function(rest, next) {
    return rest.concat(next);
  });
};

cadr = function(xs) {
  return xs[1];
};

caddr = function(xs) {
  return xs[2];
};

cadddr = function(xs) {
  return xs[3];
};

caddddr = function(xs) {
  return xs[4];
};

cadddddr = function(xs) {
  return xs[5];
};

caddddddr = function(xs) {
  return xs[6];
};

cadddddddr = function(xs) {
  return xs[7];
};

caddddddddr = function(xs) {
  return xs[8];
};

cadddddddddr = function(xs) {
  return xs[9];
};

caddddddddddr = function(xs) {
  return xs[10];
};

caar = function(xs) {
  return xs[0][0];
};

caadr = function(xs) {
  return xs[1][0];
};

caaddr = function(xs) {
  return xs[2][0];
};

caadddr = function(xs) {
  return xs[3][0];
};

caaddddr = function(xs) {
  return xs[4][0];
};

caadddddr = function(xs) {
  return xs[5][0];
};

caaddddddr = function(xs) {
  return xs[6][0];
};

caadddddddr = function(xs) {
  return xs[7][0];
};

caaddddddddr = function(xs) {
  return xs[8][0];
};

caadddddddddr = function(xs) {
  return xs[9][0];
};

caaddddddddddr = function(xs) {
  return xs[10][0];
};

possibility = function(result, str) {
  return [[result, str]];
};

impossibility = function() {
  return [];
};

is_possible = function(xs) {
  return 0 < xs.length;
};

is_impossible = function(xs) {
  return xs.length === 0;
};

shallow_flatten = function(xss) {
  return xss.reduce((function(ys, xs) {
    return ys.concat(xs);
  }), []);
};

given = function(possibilities, f) {
  return shallow_flatten(possibilities.map(function(_arg) {
    var result, str;
    result = _arg[0], str = _arg[1];
    return f(result, str);
  }));
};

also = append;

given_seq = (function() {
  var iter;
  iter = function(possibilities, procs) {
    if (procs.length === 0) {
      return possibilities;
    } else {
      return given(possibilities, function(_, str) {
        return iter(procs[0](str), procs.slice(1));
      });
    }
  };
  return function() {
    var possibilities, procs;
    possibilities = arguments[0], procs = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return iter(possibilities, Array.prototype.slice.call(procs, 0));
  };
})();

repeat = function(n, c) {
  if (n === 0) {
    return '';
  } else {
    return c + repeat(n - 1, c);
  }
};

least_acceptable_indent = function(indent, max) {
  var candidates, _i, _results;
  candidates = (function() {
    _results = [];
    for (var _i = 0; 0 <= max ? _i <= max : _i >= max; 0 <= max ? _i++ : _i--){ _results.push(_i); }
    return _results;
  }).apply(this).filter(indent);
  if (candidates.length === 0) {
    return false;
  } else {
    return repeat(candidates[0], ' ');
  }
};

compose = function() {
  var f, others, others_composed;
  f = arguments[0], others = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  if (others.length === 0) {
    return f;
  } else {
    others_composed = apply(compose, others);
    return function() {
      return f(apply(others_composed, arguments));
    };
  }
};
